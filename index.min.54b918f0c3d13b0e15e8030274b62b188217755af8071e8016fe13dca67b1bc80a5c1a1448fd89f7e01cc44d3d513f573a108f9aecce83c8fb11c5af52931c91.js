var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],field:["title","description","content"],index:["title","description","content"]}});e.add({id:0,href:"https://criteo.github.io/command-launcher/docs/quickstart/",title:"Quickstart",description:"",content:""}),e.add({id:1,href:"https://criteo.github.io/command-launcher/docs/quickstart/binary-install/",title:"Binary install",description:"Install command launcher with pre-built binaries",content:`Download pre-built binaries #Pre-built binaries can be downloaded from the Github release page. Copy the binary into your PATH.
The pre-built binary is named cdt (Criteo Dev Toolkit), if you want to use a different name, you can build your own binaries from source. See build from source.
Setup auto-completion #Command launcher will automatically handle auto completion for all sub commands. You need to setup it once:
Bash #\$ source \u0026lt;(cdt completion bash) # To load completions for each session, execute once: # Linux: \$ cdt completion bash \u0026gt; /etc/bash_completion.d/cdt # macOS: \$ cdt completion bash \u0026gt; \$(brew --prefix)/etc/bash_completion.d/cdt Zsh ## If shell completion is not already enabled in your environment, # you will need to enable it. You can execute the following once: \$ echo \u0026quot;autoload -U compinit; compinit\u0026quot; \u0026gt;\u0026gt; ~/.zshrc # To load completions for each session, execute once: \$ cdt completion zsh \u0026gt; \u0026quot;\${fpath[1]}/_cdt\u0026quot; # You will need to start a new shell for this setup to take effect. Powershell #PS\u0026gt; cdt completion powershell | Out-String | Invoke-Expression # To load completions for every new session, run: PS\u0026gt; cdt completion powershell \u0026gt; cdt.ps1 # and source this file from your PowerShell profile. Fish #\$ cdt completion fish | source # To load completions for each session, execute once: \$ cdt completion fish \u0026gt; ~/.config/fish/completions/cdt.fish Uninstall #Simply delete the binary.
Build from source #Command launcher is easy to build from source, follow the instructions
`}),e.add({id:2,href:"https://criteo.github.io/command-launcher/docs/quickstart/build-from-source/",title:"Build from source",description:"Build command launcher from source",content:`Why does the binary name matter? #Command launcher is designed for both enterprise and individual usage. According to your context, you might want to call it differently. For example, at Criteo, we call it \u0026ldquo;Criteo Dev Toolkit\u0026rdquo;. The binary name is used for several default configurations, for example, command launcher home \$HOME/.[APP_NAME], resources environment prefix [APP_NAME]_, etc.
The pre-built binary is call cdt (Criteo Dev Toolkit), which means that the default home folder is \$HOME/.cdt and the resources environment variables are all starts with CDT_.
To use a different name, you need to build command launcher from source and pass the desired short and long name to the build scripts.
Build from source #Requirements: golang \u0026gt;= 1.17
You can build the command launcher with your prefered name (in the example: Criteo Developer Toolkit, a.k.a cdt).
go build -o cdt -ldflags='-X main.version=dev -X main.appName=cdt -X \u0026quot;main.appLongName=Criteo Dev Toolkit\u0026quot;' main.go Or simply call the build.sh scripts
./build.sh [version] [app name] [app long name] Run tests #go test -v ./... `}),e.add({id:3,href:"https://criteo.github.io/command-launcher/docs/overview/",title:"Overview",description:"Command Launcher Overview",content:""}),e.add({id:4,href:"https://criteo.github.io/command-launcher/docs/overview/introduction/",title:"Introduction",description:"Overall introduction of command launcher",content:`What is command launcher? #Command launcher is a small footprint, rich feature CLI management tool for both enterprise and individual CLI developers. It eases the command line tool development by providing built-in common functionalities like: monitoring, progressive rollout, auto-completion, credential management, and more to your commands.
Why a command launcher? #At Criteo, we have many teams who provides command line applications for developers. These CLI providers repeatly handle the same features and functionalities for their CLI apps, such as auto-completion, credential management, release, delivery, monitoring, etc.
On developer side, they have to manually download these tools to keep them up-to-date, it is difficult for them to discover available new tools. On the other hand, different developers have developed lots of similar handy scripts/tools by themselves without an easy way to share with others to avoid \u0026ldquo;re-inventing\u0026rdquo; the wheel.
To improve both developer and CLI provider\u0026rsquo;s experience, we developed a command launcher to solve the above issues. It has built-in features like auto-completion, credential management, progressive roll-out, and monitoring, so that the CLI app provider can focus on the functionality of their CLI app. Developers only need to download the command launcher to access all these CLI apps. The command launcher will keep their CLI application up-to-date. The dropin feature allows developers to integrate their own scripts/tools into command launcher and share with others. These scripts and tools can also benefits from built-in features like auto-completion, and monitoring.
How it works? #Command launcher is a small binary downloaded by developer in their development environment. CLI provider packages new commands or new version of command into a package, upload it to a remote repository, and update the package index of the repository. This process can be automated. More details about the remote repository, see CLI Provider Guide
Developers can integrate their own commands into command launcher as a \u0026ldquo;dropin\u0026rdquo; package. These dropin package will be only accessible from the developers themselves. To share such commands see Dropin Package
Developers run command launcher to access these commands, for example, you have a command called toto, instead of run it directly from command line, you use cl toto, where cl is the binary name of the command launcher, you can name it anything suits you. Every time you execute command launcher, it will synchronize with the remote command, and propose available updates if exists.
┌──────────────────┐ Synch ┌───────────────────────────┐ ┌──────────────│ command launcher │◄────────────│ Remote Command Repository │ │ └──────────────────┘ └───────────────────────────┘ │ │ │ │ ┌──────────┼──────────┐ ┌────────────┼────────────┐ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ┌─────────┐ ┌───────┐ ┌───────┐ ┌───────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ dropins │ │ cmd A │ │ cmd B │ │ cmd C │ │ cmd A │ │ cmd B │ │ cmd C │ └────┬────┘ └───────┘ └───────┘ └───────┘ └─────────┘ └─────────┘ └─────────┘ ┌──────┴──────┐ ▼ ▼ ┌────────┐ ┌────────┐ │ cmd D │ │ cmd E │ └────────┘ └────────┘ Features #Small footprint. Command launcher is around 10M, with no dependency to your OS. Technology agnostic. It can launch commands implemented in any technology, and integrate to it with a simple manifest file. Auto-completion. It supports auto-completion for all your commands installed by it. Auto-update. Not only keeps itself but all its commands up-to-date. Credential management. With the built-in login command, it securely passes user credential to your command. Progressive rollout. Target a new version of command to a group of beta test users, and rollout progressively to all your users. Monitoring. Built-in monitoring feature to monitor the usage your commands. Dropins. Easy to intergrate your own command line scripts/tools by dropping your manifest in the \u0026ldquo;dropins\u0026rdquo; folder. Installation #Pre-built binary can be downloaded from the release page. Unzip it, copy the binary into your PATH.
The pre-built binary is named cdt (Criteo Dev Toolkit), if you want to use a different name, you can pass your prefered name in the build. See build section below.
Build #Requirements: golang \u0026gt;= 1.17
You can build the command launcher with your prefered name (in the example: Criteo Developer Toolkit, a.k.a cdt).
go build -o cdt -ldflags='-X main.version=dev -X main.appName=cdt -X \u0026quot;main.appLongName=Criteo Dev Toolkit\u0026quot;' main.go Or simply call the build.sh scripts
./build.sh [version] [app name] [app long name] Run tests #go test -v ./... Release #Simply tag a commit with format \u0026lsquo;x.y.z\u0026rsquo;, and push it.
git tag x.y.z git push origin x.y.z The supported release tag format:
*.*.* *.*.*-* Example: 1.0.0, 1.0.1-preview
`}),e.add({id:5,href:"https://criteo.github.io/command-launcher/docs/overview/built-in-commands/",title:"Built-in commands",description:"Command launcher built-in commands",content:`config #Get or set command launcher configuration.
Use cdt config to list all configurations.
Use cdt config [key] to get one configuration.
Use cdt config [key] [value] to set one configuration.
completion #Setup auto completion. See help to get instructions:
cdt completion --help login #Store your credentials securely and pass them to managed commands when requested and under your agreements. More details see: Managed resources
update #Check updates for command launcher and managed commands.
version #Return command launcher version information.
`}),e.add({id:6,href:"https://criteo.github.io/command-launcher/docs/overview/provider-guide/",title:"CLI provider guide",description:"Complete guide to integrate your CLI to command launcher",content:` NOTE: in this page, we use cdt as the command launcher\u0026rsquo;s binary name, you can build your own command launcher with a different name. See: build from source
Command launcher synchronizes commands from the remote command repository. Commands are packaged into a package, then uploaded to remote command repository. The following diagram shows this architecture.
┌─────────────────────────────┐ │ Remote Command Repository │ └──────────────┬──────────────┘ ┌───────────┴────────────┐ ▼ ▼ ┌────────────┐ ┌───────────┐ │ pacakge 1 │ │ pakcage 2 │ └────────────┘ └───────────┘ │ │ ┌───────┤─────────┐ ┌───┴────┐ ▼ ▼ ▼ ▼ ▼ ┌───────┐┌───────┐┌───────┐ ┌───────┐┌───────┐ │ cmd A ││ cmd B ││ cmd C │ │ cmd D ││ cmd E │ └───────┘└───────┘└───────┘ └───────┘└───────┘ Remote command repository #A remote command repository is a simple http server, with following endpoints:
/index.json: package registry, which returns the list of packages available. /{package-name}-{version}.pkg: download endpoint of a particular package. /version: returns the metadata of the latest version of command launcher. /{version}/{os}/{arch}/{binary-name}: endpoints that download command launcher binary. It is up-to-you to implement such an http server. You can configure command launcher to point to your remote repository with following command:
cdt config command_repository_base_url https://my-remote-repository/root/url You need to config an endpoint to auto update command launcher as well:
cdt config self_update_base_url https://my-remote-repository/cdt/root/url cdt config self_update_latest_version_url https://my-remote-repository/cdt/root/url/version Remote repository registry /index.json #Remote repository registry is a json file, which contains all available packages:
The following example demonstrates a registry, which has three packages. Note that the package \u0026ldquo;hotfix\u0026rdquo; has two different versions, and the version 1.0.0-45149 targets to 30% of the user (partition 6, 7, and 8). More details about the partition see Progressive Rollout
[ { \u0026quot;name\u0026quot;: \u0026quot;hotfix\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0-44733\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;5f5f47e4966b984a4c7d33003dd2bbe8fff5d31bf2bee0c6db3add099e4542b3\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 }, { \u0026quot;name\u0026quot;: \u0026quot;hotfix\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0-45149\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;773a919429e50346a7a002eb3ecbf2b48d058bae014df112119a67fc7d9a3598\u0026quot;, \u0026quot;startPartition\u0026quot;: 6, \u0026quot;endPartition\u0026quot;: 8 }, { \u0026quot;name\u0026quot;: \u0026quot;env\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;c87a417cce3d26777bcc6b8b0dea2ec43a0d78486438b1bf3f3fbd2cafc2c7cc\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://the-url-of-the-env-package/package.zip\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 } ] Please note that for \u0026ldquo;env\u0026rdquo; package, the presence of a url field indicates a different location to download the package than the url defined in configuration: command_repository_base_url. It enables the distributed package storage.
Command launcher version metadata /version #Command launcher update itself by checking an endpoint defined in config self_update_latest_version_url. This endpoint returns the command version metadata:
{ \u0026quot;version\u0026quot;: \u0026quot;45861\u0026quot;, \u0026quot;releaseNotes\u0026quot;: \u0026quot;- feature 1\\n-feature 2\\nfeature 3\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 } You can also target a small portion of your command user by specifying the partition. More details see: Progressive Rollout
Integrate your command into command launcher #Package your command into a command package #A command package = zip(your commands, manifest file)
A command package is simply a zip of your command and a manifest file that tell command launcher how to run your command. It is up-to-you to organize the structure of the package, the only requirement here is to keep the manifest.mf file in the root of the package.
For example, the following structure keeps the binary in different folder according to the os.
my-package.pkg ├─linux/ ├─windows/ ├─macosx/ └─manifest.mf Package manifest file, manifest.mf #See manifest.mf specification
Upload your package, and update package registry #Once you have your command package ready, you can upload it to the remote command repository. Depends on how you implement the http server of your remote command repository, the upload process could be different, The only requirement here is to ensure your package can be downloaded from: https://command_repository_base_url/[package-name]-[package-version].pkg
Upload your package to the remote repository server is optional, you can upload your package to any http server that can be accessed by command launcher, and specify the url in the remote repository index.json
You also need to update the index.json endpoint to include your package in it.
Progressive Rollout #Command launcher will assign each machine a unique partition ID from 0 to 9. When you roll out your package, you can specify the partition that you want to target to. For example, you just developed a new version, packaged into package my-pkg 1.1.0, uploaded it to remote repository. You can edit the /index.json registry, add following entry to target 40% of your audience (partition 4, 5, 6, and 7):
{ \u0026quot;name\u0026quot;: \u0026quot;my-pkg\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.1.0\u0026quot; \u0026quot;checksum\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;startPartition\u0026quot;: 4, \u0026quot;endPartition\u0026quot;: 7 } You will have different monitoring vectors for each partition, which will help you making A/B tests.
Monitoring #Credential Management #`}),e.add({id:7,href:"https://criteo.github.io/command-launcher/docs/overview/config/",title:"Configuration",description:"List of command launcher configurations",content:`List of configurations #Config Name Type Description ci_enabled bool whether the CI mode is enabled or not command_repository_base_url string the base url of the remote repository, it must contain a /index.json endpoint to list the available pacakges command_update_enabled bool whether auto update managed commands or not dropin_folder string the absolute path of the dropin folder enabled_user_consent bool whether enable the user consent. Be caution, when set to false, all resources are allowed to pass to the managed commands. experimental_command_enabled bool whether enable experimental command or not internal_command_enabled bool whether enable internal command or not local_command_repository_dirname bool the absolute path of the local repository folder. log_enabled bool whether log is enabled or not log_level string the log level of command launcher. Note, the managed command could also request access to this config metric_graphite_host string graphite url for metrics package_lock_file string only available for CI mode (ci_enabled = true). Lock the package version for CI purpose remote_config_check_cycle int interval in hours to check the remote config remote_config_check_time time next remote config check time. This configuration is set automatically by command launcher, you shouldn\u0026rsquo;t change it manually. self_update_base_url string base url to get command launcher binaries self_update_enabled bool whether auto update command launcher itself self_update_latest_version_url string url to get the latest command launcher version information self_update_timeout duration timeout duration for self update usage_metrics_enabled bool whether enable metrics user_consent_life duration the life of user consent Change configuration #It is recommended to use the built-in config command to change the configurations. For duration type configurations, you can use h, m, and s to present hour, minute, and seconds. For example:
cdt config user_consent_life 24h sets the user consent life to 24 hours.
`}),e.add({id:8,href:"https://criteo.github.io/command-launcher/docs/overview/manifest/",title:"Manifest.mf",description:"Specification of manifest.mf file",content:`What is a manifest.mf file? #A manifest.mf file is a file located at the root of your command launcher package. It describes the commands packaged in the zip file. When cdt install a package, it read the manifest file and register the commands in the manifest file.
Format of manifest.mf #manifest.mf is in JSON or YAML format. It contains 3 fields:
pkgName: a unique name of your package version: the version of your package cmds: a list of command definition, see command definition section Here is an example
{ \u0026quot;pkgName\u0026quot;: \u0026quot;hotfix\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0-44231\u0026quot;, \u0026quot;cmds\u0026quot;: [ ... ] } Command Definition #Command launcher is implemented with cobra. It follows the same command concepts:
Commands represent actions, Args are things and Flags are modifiers for those actions.
The best applications read like sentences when used, and as a result, users intuitively know how to interact with them.
The pattern to follow is APPNAME VERB NOUN \u0026ndash;ADJECTIVE or APPNAME COMMAND ARG \u0026ndash;FLAG.
Each package contains multiple command definitions. You can specify following definition for your command:
Command properties list #Property Required Description name yes the name of your command type yes the type of the command, group or executable group no the group of your command belongs to, default, command launcher root short yes a short description of your command, it will be display in auto-complete options long no a long description of your command argsUsage no custom the one line usage in help examples no a list of example entries executable yes for executable the executable to call when executing your command args no the argument list to pass to the executable, command launcher arguments will be appended to the list validArgs no the static list of options for auto-complete the arguments validArgsCmd no array of string, command to run to get the dynamic auto-complete options for arguments requiredFlags no the static list of options for the command flags checkFlags no whether check the flags defined in manifest before calling the command, default false requestedResources no the resources that the command requested, ex, USERNAME, PASSWORD Command properties #name #The name of the command. A user uses the group and the name of the command to run it:
cdt {group} {name} You must make sure your command\u0026rsquo;s group and name combination is unique
type #There are two types of commands: group or executable
An executable type of command is meant to be executed. You must fill the executable and args fields of an executable command.
A group type of command is used to group executable commands.
group #The group of your command. A user uses the group and the name of your command to run it:
cdt {group} {name} You must make sure your command\u0026rsquo;s group and name combination is unique
To registry a command at the root level of command launcher, set group to empty string.
Note: command launcher only supports one level of group, the \u0026ldquo;group\u0026rdquo; field of a \u0026ldquo;group\u0026rdquo; type command is ignored.
Example
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;infra\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;group\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;reintall\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;infra\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/reinstall\u0026quot;, \u0026quot;args\u0026quot;: [] } ... ] } The above manifest snippet registered a command: cdt infra reinstall, when triggered, it will execute the reinstall binary located in the package\u0026rsquo;s bin folder
short #The short description of the command. It is mostly used as the description in auto-complete options and the list of command in help output. Please keep it in a single line.
long #The long description of the command. In case your command doesn\u0026rsquo;t support \u0026ldquo;-h\u0026rdquo; or \u0026ldquo;\u0026ndash;help\u0026rdquo; flags, command launcher will generate one help command for you, and render your long description in the output.
argsUsage #Custom the one-line usage message. By default, command launcher will generate a one-line usage in the format of:
Usage: APP_NAME group command_name [flags] For some commands that accept multiple types of arguments, it would be nice to have a usage that show the different argument names and their orders. For example, for a command that accepts the 1st argument as country, and 2nd argument as city name, we can custom the usage message with following manifest:
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/get-city-population.sh\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;argsUsage\u0026quot;: \u0026quot;country city\u0026quot; } ... ] } The help message looks like:
Usage: cdt get-city-population country city [flags] examples #You can add examples to your command\u0026rsquo;s help message. The examples property defines a list of examples for your command. Each example contains two fields: scenario and command:
scenario, describes the use case. cmd, demonstrates the command to apply for the particular use case. For example:
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/get-city-population.sh\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;argsUsage\u0026quot;: \u0026quot;country city\u0026quot; \u0026quot;examples\u0026quot;: [ { \u0026quot;scenario\u0026quot;: \u0026quot;get the city population of Paris, France\u0026quot;, \u0026quot;cmd\u0026quot;: \u0026quot;get-city-population France Paris\u0026quot; } ] } ... ] } The help message looks like:
... Usage: cdt get-city-population country city [flags] Example: # get the city population of Paris, France get-city-population France Paris ... executable #The executable to call when your command is trigger from command launcher. You can inject predefined variables in the executable location string. More detail about the variables see Manifest Variables
Example
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/my-binary{{.Extension}}\u0026quot; } ] } args #The arguments that to be appended to the executable when the command is triggered. The other arguments passed from command launcher will be appeneded after these arguments that are defined in args field.
Example
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;crawler\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;java\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-jar\u0026quot;, \u0026quot;{{.PackageDir}}/bin/crawler.jar\u0026quot;] } ] } When we call this command from command launcher:
cdt crawler --url https://example.com It executes following command:
java -jar {{package path}}/bin/crawler.jar --url https://example.com Note: you can use variables in args fields as well. See Variables
validArgs #A static list of the arguments for auto-complete.
Example
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;validArgs\u0026quot;: [ \u0026quot;paris\u0026quot;, \u0026quot;rome\u0026quot;, \u0026quot;london\u0026quot; ] } ] } Once you have configured auto-complete for command launcher, the command described above will have auto-complete for its arguments.
When you type: [cdt] city population [TAB], your shell will prompt options: paris, rome, and london
validArgsCmd #A command to execute to get the dynamic list of arguments.
Example
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;validArgsCmd\u0026quot;: [ \u0026quot;{{.PackageDir}}/bin/population-cities.sh\u0026quot;, \u0026quot;-H\u0026quot;, ] } ] } When you type [cdt] city poplution [TAB], command launcher will run the command specified in this field, and append all existing flags/arguments to the validArgsCmd.
More details see: Auto-Complete
requiredFlags #The static list of flags for your command
Example
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;validArgs\u0026quot;: [ \u0026quot;paris\u0026quot;, \u0026quot;rome\u0026quot;, \u0026quot;london\u0026quot; ], \u0026quot;requiredFlags\u0026quot;: [ \u0026quot;human\\t H\\t return the human readable format\u0026quot;, ] } ] } It declares a --human flags with a short form: -H
checkFlags #Whether parse and check flags before execute the command. Default: false.
The requiredFlags, validArgs and validArgsCmd are mainly used for auto completion. Command launcher will not parse the arguments by default, it will simply pass the arguments to the callee command. In other words, in this case, it is the callee command\u0026rsquo;s responsibility to parse the flags and arguments. This works fine when the command is implemented with languages that has advanced command line supports, like golang.
For some cases, arguments parsing is difficult or has less support, for example, implementing the command in shell script. Enable checkFlags will allow command launcher to parse the arguments and catch errors. Further more, command launcher will pass the parsed flags and arguments to the callee command through environment variables:
For flags: [APP_NAME]_FLAG_[FLAG_NAME] (\u0026rsquo;-\u0026rsquo; is replaced with \u0026lsquo;_\u0026rsquo;). Example: flag --user-name is passed through environment variable [APP_NAME]_FLAG_USER_NAME
For arguments: [APP_NAME]_ARG_[INDEX] where the index starts from 1. Example: command cdt get-city-population France Paris will get environment variable [APP_NAME]_ARG_1=France and [APP_NAME]_ARG_2=Paris
Another behavior change is that once checkFlags is enabled, the -h and --help flags are handled by command launcher. The original behavior is managed by the callee command itself.
requestedResources #Under the user consent, command launcher can pass several resources to the callee command, for example, the user credential collected and stored securely by the built-in login command. The requestedResources is used to request such resources. Command launcher will prompt user consent for the first time, and pass requested resources value to the callee command through environment variable. More detail see: Manage resources
The following snippet requests to access the user name and password resources.
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;requestedResources\u0026quot;: [ \u0026quot;USERNAME\u0026quot;, \u0026quot;PASSWORD\u0026quot; ] } ] } `}),e.add({id:9,href:"https://criteo.github.io/command-launcher/docs/overview/dropin/",title:"Dropin package",description:"The easiest way to integrate your own scripts/tools to command launcher",content:`What is dropin package? and why do I need it? #A dropin package is a package that are not managed by the remote repository. It is only available on the developer\u0026rsquo;s machine. It allows developers to integrate their own scripts/tools into command launcher to benefit the feature provided by the command launcher, for example, auto-complete, monitoring etc.
For example, you probably already has lots of shell scripts to maintain your infrastructure. Writing auto-completion for all these scripts is time consuming and it is difficult to remember which script doing what, and what parameters they accept. By writing a simple manifest.mf file, you can let command launcher to manage these scripts for you with auto-complete, secret management, and monitoring.
Dropin package is also a good way for you to develop and test your command launcher package, as it follows the same structure as a regular command launcher package.
How to create a dropin package? #identify the dropins folder: run the following command:
cdt config dropin_folder If the dropin folder returned by the command doesn\u0026rsquo;t exist, create it.
create a package folder in the dropin folder, let\u0026rsquo;s say, a package named my-first-package. You can named it whatever you want.
add a manifest.mf in the newly created package folder, follow MANIFEST.md guide to define your command in the manifest file. Note: you can copy your scripts in the package folder and use {{.PackageDir}} to reference the package location in your manifest file.
run cdt any time to test your command
How to share a dropin package with others? #A dropin package is simply a directory with manifest.mf in it, the best way to share a dropin package is to push it to a git repository and ask for others to clone it in their own dropin folder
How to update dropin package? #For now, the command launcher does not update the dropin folder automatically, it is up to developers themselve to keep these dropin package up-to-date.
`}),e.add({id:10,href:"https://criteo.github.io/command-launcher/docs/overview/resources/",title:"Manage resources",description:"Access informations that collected from command launcher",content:`What is resources #Resources are the information collected by command launcher. One good example is the user name and password from the built-in login command.
To access these information, a command needs to explicitly request the access to these resources through requestedResources property in the manifest.
For example, the following snippet of manifest requests the resource USERNAME and LOGIN_TOKEN.
pkgName: infra-management version: 1.0.0 cmds: - name: create-pod ... requestedResources: [ \u0026quot;USERNAME\u0026quot;, \u0026quot;LOGIN_TOKEN\u0026quot; ] User consent #Command launcher will pass the resources to the command on runtime through environment variables: [APP_NAME]_[RESOURCE_NAME], ONLY IF user has agreed to do so. This is done through a user consent process, with a prompt message for the first-time run of the command:
Command 'create-pod' requests access to the following resources: - USERNAME - LOGIN_TOKEN authorize the access? [yN] The user consent will last for a specific period of time define in user_consent_life configuration.
Access resources in your command #Once user grant the access to the requested resources, command launcher will pass the resources to the command in runtime through environment variable with naming convention: [APP_NAME]_[RESOURCE_NAMe]. Here is an example of bash script:
#!/bin/bash USERNAME=\${CDT_USERNAME} LOGIN_TOKEN=\${CDT_LOGIN_TOKEN} Available resources #Resource Name Description USERNAME the username collected from login command PASSWORD the password collected from login command LOG_LEVEL the log level of command launcher DEBUG_FLAGS the debug flags defined in command launcher\u0026rsquo;s config `}),e.add({id:11,href:"https://criteo.github.io/command-launcher/docs/tutorial/",title:"Tutorials",description:"",content:""}),e.add({id:12,href:"https://criteo.github.io/command-launcher/docs/overview/variable/",title:"Variable",description:"Use variables in manifest.mf file",content:`The two common use cases of integrating commands in command launcher are:
Reference files that are located in the package itself Provide system/architecture-aware commands, for example, .sh script for linux, and .bat script for windows To cover these use cases, in certain fields of the manifest file, predefined variables can used in the field values.
Available Variables #Variable Name Variable Description PackageDir The absolute path of the package Root Same as \u0026ldquo;PackageDir\u0026rdquo; variable Cache Same as \u0026ldquo;PackageDir\u0026rdquo; variable Os The OS, \u0026ldquo;windows\u0026rdquo;, \u0026ldquo;linux\u0026rdquo;, and \u0026ldquo;darwin\u0026rdquo; Arch The system architecture: \u0026ldquo;arm64\u0026rdquo;, \u0026ldquo;amd64\u0026rdquo; Binary The binary file name of the command launcher Extension The system-aware binary extension, \u0026quot;\u0026quot; for linux, \u0026ldquo;.exe\u0026rdquo; for windows ScriptExtension The system-aware scritp extension, \u0026ldquo;.sh\u0026rdquo; for linux, \u0026ldquo;.bat\u0026rdquo; for windows Fields that accepts variables #The command fields: executable, args, and validArgsCmd
How to use these variables #You can reference them in form of {{.Variable}}. For example:
\u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;variable-demo\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/script{{.ScripteExtension}}\u0026quot;, } ] The executable on linux will be a script called script.sh located in the bin folder of the package. On windows, the executable will be a script called script.bat.
Advanced usage of variables #See golang text/template for advanced usage (ex, if else)
`}),e.add({id:13,href:"https://criteo.github.io/command-launcher/docs/",title:"Docs",description:"Command Launcher Docs",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()