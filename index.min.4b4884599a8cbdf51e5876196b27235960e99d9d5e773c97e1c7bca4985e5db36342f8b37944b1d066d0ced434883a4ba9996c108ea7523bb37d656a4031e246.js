var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],field:["title","description","content"],index:["title","description","content"]}});e.add({id:0,href:"https://criteo.github.io/command-launcher/docs/quickstart/",title:"Quickstart",description:"",content:""}),e.add({id:1,href:"https://criteo.github.io/command-launcher/docs/quickstart/binary-install/",title:"Binary install",description:"Install command launcher with pre-built binaries",content:`Download pre-built binaries #Pre-built binaries can be downloaded from the Github release page. Copy the binary into your PATH.
The default pre-built binary is named cola (Command Launcher), if you want to use a different name, you can build your own binaries from source. See build from source.
For example, in each release, we also build a binary named cdt (Criteo Dev Toolkit). If you prefer to download cdt, please replace cola to cdt in the examples from the documents.
Setup auto-completion #Command launcher will automatically handle auto completion for all sub commands. You need to setup it once:
Bash #\$ source \u0026lt;(cola completion bash) # To load completions for each session, execute once: # Linux: \$ cola completion bash \u0026gt; /etc/bash_completion.d/cola # macOS: \$ cola completion bash \u0026gt; \$(brew --prefix)/etc/bash_completion.d/cola Zsh ## If shell completion is not already enabled in your environment, # you will need to enable it. You can execute the following once: \$ echo \u0026quot;autoload -U compinit; compinit\u0026quot; \u0026gt;\u0026gt; ~/.zshrc # To load completions for each session, execute once: \$ cola completion zsh \u0026gt; \u0026quot;\${fpath[1]}/_cola\u0026quot; # You will need to start a new shell for this setup to take effect. Powershell #PS\u0026gt; cola completion powershell | Out-String | Invoke-Expression # To load completions for every new session, run: PS\u0026gt; cola completion powershell \u0026gt; cola.ps1 # and source this file from your PowerShell profile. Fish #\$ cola completion fish | source # To load completions for each session, execute once: \$ cola completion fish \u0026gt; ~/.config/fish/completions/cola.fish Uninstall #Simply delete the binary.
Build from source #Command launcher is easy to build from source, follow the instructions
`}),e.add({id:2,href:"https://criteo.github.io/command-launcher/docs/quickstart/build-from-source/",title:"Build from source",description:"Build command launcher from source",content:`Why does the binary name matter? #Command launcher is designed for both enterprise and individual usage. According to your context, you might want to call it differently. For example, at Criteo, we call it \u0026ldquo;Criteo Dev Toolkit\u0026rdquo;. The binary name is used for several default configurations, for example, command launcher home \$HOME/.[APP_NAME], additional resources environment prefix [APP_NAME]_, etc.
The default pre-built binary is call cola (Command Launcher), which means that the default home folder is \$HOME/.cola and the resources environment variables are all starts with COLA_.
Another pre-built binary is called cdt (Criteo Dev Toolkit), its home folder will be \$HOME/.cdt, and its commands can access the resource environment variables with both prefix COLA_ and CDT_.
For compatibility concern, we highly recommend to reference resources in your command with prefix COLA_
To use a different name, you need to build command launcher from source and pass the desired short and long name to the build scripts.
Build from source #Requirements: golang \u0026gt;= 1.17
You can build the command launcher with your prefered name (in the example: Command Launcher, a.k.a cola).
go build -o cola -ldflags='-X main.version=dev -X main.appName=cola -X \u0026quot;main.appLongName=Command Launcher\u0026quot;' main.go Or simply call the build.sh scripts
./build.sh [version] [app name] [app long name] Run tests #Run unit tests
go test -v ./... Run all integration tests
./test/integration.sh You can run one integration test by specify the name of the integration test file (without the .sh extension). The integration tests can be found in test/integration folder, for example:
./test/integration.sh test-remote `}),e.add({id:3,href:"https://criteo.github.io/command-launcher/docs/quickstart/first-command/",title:"Quick Start",description:"Integrate your first command to command launcher",content:`Preparation #If you want to use the default command launcher binary name (cola): install command launcher following the guide Binary install. Or if you prefer a different binary name, build command launcher from source: Build from source
In Criteo, we call it cdt, (Criteo Dev Toolkit)
In this tutorial, we will use the binary name cola.
To check your command launcher installation, run following command:
cola config It should list all your configurations. The important ones for this tutorial is the following:
dropin_folder : [command launcher home]/dropins local_command_repository_dirname : [command launcher home]/current Default command launcher home: MacOS/Users/[user_name]/[.binary_name] Linux/home/[user_name]/[.binary_name] WindowsC:\\Users\\[user_name]\\[.binary_name]
For example, on my Macbook (with user criteo), my command launcher home is /Users/criteo/.cola
Command launcher also provide auto-completion feature to all managed commands, you only need to setup auto-completion once: setup auto-completion
Let\u0026rsquo;s build a command #If you already have a command you can skip this step. Command launcher is technology agnostic to your command. You can build your command in any tech stack that suits your use case. In this tutorial, let\u0026rsquo;s build a simple \u0026ldquo;Hello World\u0026rdquo; command line tool with bash scripts.
In command launcher, commands are packaged into packages. Let\u0026rsquo;s first create a package for our newly created command:
cd \$HOME/.cola/dropins mkdir my-first-package cd my-first-package Create a script file first-command-launcher-cmd.sh, which prints greeting message according to the language
#!/bin/bash LANG=\${LANG:-en} if [ \$LANG == \u0026quot;fr\u0026quot; ]; then echo \u0026quot;Bonjour! \$1\u0026quot; exit 0 else echo \u0026quot;Hello! \$1\u0026quot; exit 0 fi You can run it directly as a normal bash script:
\$ ./first-command-launcher-cmd.sh \u0026quot;command launcher\u0026quot; Hello! command launcher \$ LANG=fr ./first-command-launcher-cmd.sh \u0026quot;command launcher\u0026quot; Bonjour! command launcher Prepare a minimal manifest.mf #Now we have a working command/script. To make command launcher aware of it, we need to create a manifest file (in JSON or YAML format) at the root folder of the package:
manifest.mf
pkgName: my-first-package version: 0.0.1 cmds: - name: greeting type: executable executable: \u0026quot;{{.PackageDir}}/first-command-launcher-cmd.sh\u0026quot; That\u0026rsquo;s it! Your command has been integrated to command launcher with a subcommand named greeting, to test it:
\$ cola greeting \u0026quot;command launcher\u0026quot; Hello! command launcher \$ LANG=fr cola greeting \u0026quot;command launcher\u0026quot; Bonjour! command launcher Command launcher will pass all the environment variables, arguments to itself to your command.
Tell more about your command to command launcher #We can go even further to turn our bash scripts into a native-like program. Let\u0026rsquo;s add extra information in the manifest, and make some improvements of its user interface:
the short and long description some examples use a flag to take language input instead of environment variable LANG pkgName: my-first-package version: 0.0.2 cmds: name: greeting type: executable short: Simple greeting command executable: \u0026quot;{{.PackageDir}}/first-command-launcher-cmd.sh\u0026quot; requiredFlags: - \u0026quot;language\\t greeting language\u0026quot; examples: - scenario: Greeting with default language cmd: greeting [name] - scenario: Specify the greeting language cmd: greeting --language fr [name] checkFlags: true The above manifest tells command launcher that the greeting command requires a flags called language, and let command launcher to check the flags before calling the script
Now when you run the greeting command with -h or --help, you will get a nice help message like a native command:
\$ cola greeting -h Usage: cola greeting [flags] Examples: # Greeting with default language greeting [name] # Specify the greeting language greeting --language fr [name] Flags: -h, --help help for greeting --language string greeting language But how can our script get the language passed from the --language flag? Command launcher passes an environment variable to your script with the name CDT_FLAG_LANGUAGE (More details see checkFlags). You can modify your script to get the language from it like so:
#!/bin/bash LANG=\${COLA_FLAG_LANGUAGE:-en} if [ \$LANG == \u0026quot;fr\u0026quot; ]; then echo \u0026quot;Bonjour! \$1\u0026quot; exit 0 else echo \u0026quot;Hello! \$1\u0026quot; exit 0 fi Now we have turned our bash script into a native-like command.
Auto-completion #Command launcher will automatically enable auto-completion for your command. Subcommand, flags, arguments will will be auto-completed when you type [TAB][TAB], for example:
\$ cola g[TAB][TAB] greeting - Simple greeting command grepx - Enhanced grep command \$ cola greeting --[TAB][TAB] \$ cola greeting --language `}),e.add({id:4,href:"https://criteo.github.io/command-launcher/docs/overview/",title:"Overview",description:"Command Launcher Overview",content:""}),e.add({id:5,href:"https://criteo.github.io/command-launcher/docs/overview/introduction/",title:"Introduction",description:"Overall introduction of command launcher",content:`What is command launcher? #Command launcher is a small-footprint, feature-rich CLI management tool for both enterprise and individual CLI developers. It eases the command line tool development by providing built-in common functionalities like: monitoring, progressive rollout, auto-completion, credential management, and more to your commands.
Why a command launcher? #At Criteo, we have many teams who provide command line applications for developers. These CLI providers repeatly handle the same features and functionalities for their CLI apps, such as auto-completion, credential management, release, delivery, monitoring, etc.
On the developer side, they have to manually download these tools and keep them up-to-date. It is also difficult for them to discover available new tools. On the other hand, different developers have developed lots of similar handy scripts/tools by themselves without an easy way to share with others to avoid \u0026ldquo;re-inventing\u0026rdquo; the wheel.
To improve both developer and CLI provider\u0026rsquo;s experience, we developed a command launcher to solve the above issues. It has built-in features like auto-completion, credential management, progressive roll-out, and monitoring, so that the CLI app provider can focus on the functionality of their CLI app. Developers only need to download the command launcher to access all these CLI apps. The command launcher will keep their CLI application up-to-date. The dropin feature allows developers to integrate their own scripts/tools into command launcher and share with others. These scripts and tools can also benefit from built-in features like auto-completion and monitoring.
How it works? #Command Launcher is a small binary downloaded by a developer in their development environment. CLI providers package new commands or new versions of commands into a package, upload them to a remote repository, and update the package index of the repository. This process can be automated. For more details about the remote repository, see CLI Provider Guide
Developers can integrate their own commands into Command Launcher as a \u0026ldquo;dropin\u0026rdquo; package. These dropin packages will be only accessible on the developer\u0026rsquo;s machine. To share such commands see Dropin Package
Developers run Command Launcher to access these commands. For example, if you have a command called toto, instead of running it directly from the command line, you use cl toto, where cl is the binary name of the Command Launcher (you can name it anything that suits you).
Every time you run the Command Launcher, it will synchronize with the remote command, and propose updates if they are available.
┌──────────────────┐ Synch ┌───────────────────────────┐ ┌──────────────│ Command Launcher │◄────────────│ Remote Command Repository │ │ └──────────────────┘ └───────────────────────────┘ │ │ │ │ ┌──────────┼──────────┐ ┌────────────┼────────────┐ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ┌─────────┐ ┌───────┐ ┌───────┐ ┌───────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ dropins │ │ cmd A │ │ cmd B │ │ cmd C │ │ cmd A │ │ cmd B │ │ cmd C │ └────┬────┘ └───────┘ └───────┘ └───────┘ └─────────┘ └─────────┘ └─────────┘ ┌──────┴──────┐ ▼ ▼ ┌────────┐ ┌────────┐ │ cmd D │ │ cmd E │ └────────┘ └────────┘ Features #Small footprint. Command Launcher is around 10M, with no dependency to your OS. Technology agnostic. It can launch commands implemented in any technology, and integrate them with a simple manifest file. Auto-completion. It will auto-complete the name of your commands out of the box, and their arguments if you provide the right information in the manifest file. Auto-update. Command Launcher can keep itself and its command packages up to date. Credential management. With the built-in login command, it securely passes user credentials to your commands. Progressive rollout. Target a new version of command to a group of beta test users, and rollout progressively to all your users. Monitoring. Built-in monitoring feature to monitor the usage of your commands. Dropins. Easy to integrate your own command line scripts/tools by dropping your manifest in the \u0026ldquo;dropins\u0026rdquo; folder. Installation #A pre-built binary can be downloaded from the release page. Unzip it, and place the binary in a directory in your PATH.
The two pre-built binaries are named cola (Command Launcher) and cdt (Criteo Dev Toolkit), if you want to use a different name, you can pass your preferred name in the build. See the build section below.
Building #Requirements: golang \u0026gt;= 1.17
You can build the command launcher with your preferred name (in the example: Criteo Developer Toolkit, a.k.a cdt).
go build -o cdt -ldflags='-X main.version=dev -X main.appName=cdt -X \u0026quot;main.appLongName=Criteo Dev Toolkit\u0026quot;' main.go Or simply call the build.sh script
./build.sh [version] [app name] [app long name] Running tests #Run unit tests:
go test -v ./... Run all integration tests:
./test/integration.sh You can run one integration test by specify the name of the integration test file (without the .sh extension). The integration tests can be found in test/integration folder, for example:
./test/integration.sh test-remote Releasing #Simply tag a commit with format \u0026lsquo;x.y.z\u0026rsquo;, and push it.
git tag x.y.z git push origin x.y.z The supported release tag format:
*.*.* *.*.*-* Examples: 1.0.0, 1.0.1-preview
`}),e.add({id:6,href:"https://criteo.github.io/command-launcher/docs/overview/built-in-commands/",title:"Built-in commands",description:"Command launcher built-in commands",content:`config #Get or set the Command Launcher configuration.
Use cola config to list all configuration entries.
Use cola config [key] to get one configuration entry.
Use cola config [key] [value] to set one configuration entry.
completion #Set up auto completion. See help to get instructions:
cola completion --help login #Store your credentials securely and pass them to managed commands when requested and under your agreements. For more details see: Managed resources
update #Check updates for the Command Launcher and any managed commands.
version #Return Command Launcher version information.
package #A collection of commands to manage installed packages and commands
package list #List installed packages and commands.
# list local installed packages cola package list --local # list local installed packages and commands cola package list --local --include-cmd # list dropin packages cola package list --dropin # list local dropin packages and commands cola package list --dropin --include-cmd # list remote packages cola package list --remote package install #Install a dropin package from a git repo or from a zip file.
# install a dropin package from git repository cola package install --git https://github.com/criteo/command-launcher-package-example # install a dropin package from zip file cola package install --file https://github.com/criteo/command-launcher/raw/main/examples/remote-repo/command-launcher-demo-1.0.0.pkg package delete #Remove a dropin package from the package name defined in the manifest.
cola package delete command-launcher-example-package package setup #Manually trigger the package setup hook.
cola package setup command-launcher-example-package remote #A collection of commands to manage extra remote registries. A registry is a URI that hosts multiple packages. The list of available packages of the registry is defined in its /index.json endpoint.
remote list #List remote registries.
cola remote list remote add #Add a new remote registry. Command launcher will synchronize from this remote registry once added.
cola remote add myregistry https://raw.githubusercontent.com/criteo/command-launcher/main/examples/remote-repo remote delete #Delete a remote registry by its name.
cola delete myregistry rename #rename #Rename a command into a different name.
To avoid command conflicts, each command has a unique full name in the form of [name]@[group]@[package]@[repository]. For group commands and root level commands, their group is empty. For example: hello@@my-package@dropin is the full name of the command hello in my-package package, which can be found in the dropin repository.
Usually, such command is launched through: cola [group] [name]. You can rename the group and the name of the command to a different name, so that you can call it through: cola [new group] [new name]
To rename a command to a different name, use the following commands:
# To change the group name: cola rename [group]@@[package]@[repository] [new group] # To change the command name: cola rename [name]@[group]@[package]@[repository] [new name] For example, you can rename the hello command to bonjour using following rename command:
cola rename hello@@my-package@dropin bonjour # now calling it from cola will trigger the original hello command cola bonjour rename \u0026ndash;list #available in 1.10.0+
List all renamed commands.
The Command Launcher keeps track of all renamed commands. You can list all renamed commands using the following command:
cola rename --list rename \u0026ndash;delete #Delete a renamed command name, reverting back to the original name.
cola rename --delete [command full name] Now you have to use its original name to call the command.
`}),e.add({id:7,href:"https://criteo.github.io/command-launcher/docs/overview/provider-guide/",title:"CLI provider guide",description:"Complete guide to integrate your CLI to command launcher",content:` NOTE: in this page, we use cola as the command launcher\u0026rsquo;s binary name, you can build your own command launcher with a different name. See: build from source
Command launcher synchronizes commands from the remote command repository. Commands are packaged into a package, then uploaded to remote command repository. The following diagram shows this architecture.
┌─────────────────────────────┐ │ Remote Command Repository │ └──────────────┬──────────────┘ ┌───────────┴────────────┐ ▼ ▼ ┌────────────┐ ┌───────────┐ │ pacakge 1 │ │ pakcage 2 │ └────────────┘ └───────────┘ │ │ ┌───────┤─────────┐ ┌───┴────┐ ▼ ▼ ▼ ▼ ▼ ┌───────┐┌───────┐┌───────┐ ┌───────┐┌───────┐ │ cmd A ││ cmd B ││ cmd C │ │ cmd D ││ cmd E │ └───────┘└───────┘└───────┘ └───────┘└───────┘ Remote command repository #A remote command repository is a simple http server with following endpoints:
/index.json, which returns the list of packages available. It is up-to-you to implement such an http server. You can configure command launcher to point to your remote repository with following command:
cola config command_repository_base_url https://my-remote-repository/root/url NOTE: the command launcher will search for [command_repository_base_url]/index.json for the remote registry. You can also use a local folder as the \u0026ldquo;base url\u0026rdquo;, for example, /tmp/cola-remote-repository/. In this case, you need to create the index.json registry file in the folder. This is useful for test purpose.
You need to config an endpoint to auto update command launcher itself as well:
cola config self_update_latest_version_url https://my-remote-repository/cola/root/url/version cola config self_update_base_url https://my-remote-repository/cola/root/url The self_update_latest_version_url configuration defines the url to download the metadata of command launchers\u0026rsquo;s latest version in YAML or JSON format, see: Command Launcher version metadata
The self_update_base_url configuratin defines the base url to download command launcher binary. It follows the following pattern: [SELF_UPDATE_BASE_URL]/{version}/{binaryName}_{OS}_{ARCH}_{version}{extension}. If you build your own binary, you should make it available following the same convention.
Remote repository registry /index.json #Remote repository registry is a json file, which contains all available packages:
The following example demonstrates a registry, which has three packages. Note that the package \u0026ldquo;hotfix\u0026rdquo; has two different versions, and the version 1.0.0-45149 targets to 30% of the user (partition 6, 7, and 8). More details about the partition see Progressive Rollout
[ { \u0026quot;name\u0026quot;: \u0026quot;hotfix\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0-44733\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;5f5f47e4966b984a4c7d33003dd2bbe8fff5d31bf2bee0c6db3add099e4542b3\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://the-url-of-the-env-package/any-name.zip\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 }, { \u0026quot;name\u0026quot;: \u0026quot;hotfix\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0-45149\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;773a919429e50346a7a002eb3ecbf2b48d058bae014df112119a67fc7d9a3598\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://the-url-of-the-env-package/hotfix-1.0.0-45149.zip\u0026quot;, \u0026quot;startPartition\u0026quot;: 6, \u0026quot;endPartition\u0026quot;: 8 }, { \u0026quot;name\u0026quot;: \u0026quot;env\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;c87a417cce3d26777bcc6b8b0dea2ec43a0d78486438b1bf3f3fbd2cafc2c7cc\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://the-url-of-the-env-package/package.zip\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 } ] Command launcher version metadata #Command launcher update itself by checking an endpoint defined in config self_update_latest_version_url. This endpoint returns the command version metadata:
In JSON
{ \u0026quot;version\u0026quot;: \u0026quot;45861\u0026quot;, \u0026quot;releaseNotes\u0026quot;: \u0026quot;- feature 1\\n-feature 2\\nfeature 3\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 } Or in YAML
version: \u0026quot;45861\u0026quot; releaseNotes: | * feature 1 * feature 2 * feature 3 startPartition: 0 endPartition: 9 The version metadata endpoint supports both YAML and JSON format. It is recommandded to use YAML for this endpoint because of the multiple line string support in YAML
You can also target a small portion of your command user by specifying the partition. More details see: Progressive Rollout
Integrate your command into command launcher #Package your command into a command package #A command package = zip(your commands, manifest file)
A command package is simply a zip of your command and a manifest file that tell command launcher how to run your command. It is up-to-you to organize the structure of the package, the only requirement here is to keep the manifest.mf file in the root of the package.
For example, the following structure keeps the binary in different folder according to the os.
my-package.pkg ├─linux/ ├─windows/ ├─macosx/ └─manifest.mf Package manifest file, manifest.mf #See manifest.mf specification
Upload your package, and update package registry #Once you have your command package ready, you can upload it to a remote server that command launcher have access. Depends on how you implement the http server of your remote command repository, the upload process could be different, The only requirement here is to ensure your package is accessible from command launcher.
You also need to update the index.json endpoint to include your package in it and specify the package url in the url property.
Progressive Rollout #Command launcher will assign each machine a unique partition ID from 0 to 9. When you roll out your package, you can specify the partition that you want to target to. For example, you just developed a new version, packaged into package my-pkg 1.1.0, uploaded it to remote repository. You can edit the /index.json registry, add following entry to target 40% of your audience (partition 4, 5, 6, and 7):
{ \u0026quot;name\u0026quot;: \u0026quot;my-pkg\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.1.0\u0026quot; \u0026quot;checksum\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;startPartition\u0026quot;: 4, \u0026quot;endPartition\u0026quot;: 7 } You will have different monitoring vectors for each partition, which will help you making A/B tests.
Monitoring #Command launcher current implements a built-in graphite exporter. It reports the following metrics to graphite:
success command execution count: devtools.cdt.[package name].[group].[name].ok.count success command duration: devtools.cdt.[package name].[group].[name].ok.duration fail command execution count: devtools.cdt.[package name].[group].[name].ko.count fail command duration: devtools.cdt.[package name].[group].[name].ko.duration You can add your custom metrics exporter by a __metrics__ command hook in a system package, see system package
Credential Management #Command launcher has a built-in login command, which will prompt the user to enter his user name and password. The default implementation will store the user name and password securely in the system credential manager. Each command can request the access to such credential in its manifest. Command launcher will ensure user consent on accessing these credentials and pass them to the underlying command through environment variables. More detail see Manage resources
`}),e.add({id:8,href:"https://criteo.github.io/command-launcher/docs/overview/config/",title:"Configuration",description:"List of command launcher configurations",content:`List of configurations #Config Name Type Description ci_enabled bool whether the CI mode is enabled or not command_repository_base_url string the base url of the remote repository, it must contain a /index.json endpoint to list the available pacakges command_update_enabled bool whether auto update managed commands or not dropin_folder string the absolute path of the dropin folder enable_user_consent bool whether enable the user consent. Be caution, when set to false, all resources are allowed to pass to the managed commands. experimental_command_enabled bool whether enable experimental command or not internal_command_enabled bool whether enable internal command or not local_command_repository_dirname bool the absolute path of the local repository folder. log_enabled bool whether log is enabled or not log_level string the log level of command launcher. Note, the managed command could also request access to this config metric_graphite_host string graphite url for metrics package_lock_file string only available for CI mode (ci_enabled = true). Lock the package version for CI purpose remote_config_check_cycle int interval in hours to check the remote config remote_config_check_time time next remote config check time. This configuration is set automatically by command launcher, you shouldn\u0026rsquo;t change it manually. self_update_base_url string base url to get command launcher binaries self_update_enabled bool whether auto update command launcher itself self_update_latest_version_url string url to get the latest command launcher version information self_update_timeout duration timeout duration for self update usage_metrics_enabled bool whether enable metrics user_consent_life duration the life of user consent system_package string the system package name system_package_public_key string the public key to verify the system package signature system_package_public_key_file string the public key file to verify the system package signature verify_package_checksum bool whether to verify the package checksum during package installation verify_package_signature bool whether to verify the package signature during package installation (will be available in 1.8) extra_remotes map extra remote registry configurations, see extra remote configuration (available 1.8+) enable_package_setup_hook bool call setup hook after a new version of package is installed (available 1.9+) group_help_by_registry bool group help by registry, default true (available 1.13+) extra remote configuration #Each extra remote must have a unique name, it is used to identify the command as part of the command full name. The example configuration looks like the following:
{ \u0026quot;extra_remotes\u0026quot;: { \u0026quot;remote1\u0026quot;: { \u0026quot;remote_base_url\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;sync_policy\u0026quot;: \u0026quot;always\u0026quot;, \u0026quot;repository_dir\u0026quot;: \u0026quot;\u0026quot; } } } Config Name Type Description remote_base_url string the base url of the remote repository, it must contain a /index.json endpoint to list all available packages sync_policy string how often the repository is synched from its remote. Possible value: always, hourly, daily, weekly, or monthly. (hourly, daily, weekly and monthly are supported in 1.14+) repository_dir string the absolute path of the local repository folder to keep the downloaded local packages You don\u0026rsquo;t need to manage these extra remote configurations by yourself. Use the built-in remote command instead.
Change configuration #It is recommended to use the built-in config command to change the configuration. For duration type configuration entries, you can use h, m, and s to represent hours, minutes, and seconds, respectively. For example:
cola config user_consent_life 24h will set the value of user_consent_life to 24 hours.
`}),e.add({id:9,href:"https://criteo.github.io/command-launcher/docs/overview/manifest/",title:"Manifest.mf specification",description:"Specification of manifest.mf file",content:`What is a manifest.mf file? #A manifest.mf file is a file located at the root of your Command Launcher package. It describes the commands packaged in the zip file. When cola installs a package, it reads the manifest file and registers the commands it finds described in it.
Format of manifest.mf #The manifest.mf file can be in either JSON or YAML format. It contains three top-level keys:
pkgName: a unique name of your package version: the version of your package cmds: a list of command definitions, see the Command Definition section Here is an example
{ \u0026quot;pkgName\u0026quot;: \u0026quot;hotfix\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0-44231\u0026quot;, \u0026quot;cmds\u0026quot;: [ ... ] } Command Definition #Command Launcher is implemented with cobra. It follows the same command concepts:
Commands represent actions, Args are the objects of those actions and Flags are modifiers for those actions.
The best applications read like sentences when used and, as a result, users are more likely to intuitively know how to interact with them.
The pattern to follow is APPNAME VERB NOUN --ADJECTIVE or APPNAME COMMAND ARG --FLAG.
Each package can contain multiple command definitions.
These are the properties available to define each command:
Command properties list #Property Required Description name yes the name of your command type yes the type of the command, group or executable group no the group of your command belongs to. Default: Command Launcher root short yes a short description of your command, it will be displayed in auto-complete options long no a long description of your command argsUsage no customize the one-line usage in help output examples no a list of example entries executable yes for executable the executable to call when running your command args no the argument list to pass to the executable, Command Launcher arguments will be appended to this list validArgs no the static list of options for auto-completing the arguments validArgsCmd no (array of strings) command to run to get the dynamic auto-complete options for arguments requiredFlags no the static list of options for the command flags (deprecated in 1.9) flags no the flag list (available in 1.9+) exclusiveFlags no group of exclusive flags (available in 1.9+) groupFlags no group of grouped flags, which must be presented together (available in 1.9+) checkFlags no whether to check the flags defined in manifest before calling the command. Default: false requestedResources no the resources that the command requested, e.g., USERNAME, PASSWORD Command properties #name #The name of the command. A user uses the group and the name of the command to run it:
cola {group} {name} You must make sure your command\u0026rsquo;s group and name combination is unique.
type #There are three types of commands: group, executable, and system.
An executable command is meant to be executed. You must fill the executable and args fields of an executable command.
A group command is used to group executable commands. It does not run anything by itself.
A system command is an executable command which extends some built-in Command Launcher functions. For more details see system package
group #The group of your command. A user uses the group and the name of your command to run it:
cola {group} {name} You must make sure your command\u0026rsquo;s group and name combination is unique.
To register a command at the root level of Command Launcher, set the group to an empty string.
Note: command launcher only supports one level of grouping, the \u0026ldquo;group\u0026rdquo; field of a \u0026ldquo;group\u0026rdquo; type command is ignored.
Example:
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;infra\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;group\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;reintall\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;infra\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/reinstall\u0026quot;, \u0026quot;args\u0026quot;: [] } ... ] } The above manifest snippet registered a command: cola infra reinstall. When triggered, it will execute the reinstall binary located in the package\u0026rsquo;s bin folder
short #The short description of the command. It is mostly used as the description in auto-complete options and the list of command in help output. Please keep it in a single line.
long #The long description of the command. In case your command doesn\u0026rsquo;t support \u0026ldquo;-h\u0026rdquo; or \u0026ldquo;\u0026ndash;help\u0026rdquo; flags, command launcher will generate one help command for you, and render your long description in the output.
argsUsage #Customize the one-line usage message. By default, Command Launcher will generate a one-line usage in the format of:
Usage: APP_NAME group command_name [flags] For some commands that accept multiple types of arguments, it would be nice to have a usage message that shows the different argument names and their order. For example, for a command that accepts a country as first argument, and a city as second argument, we can customize the usage message with the following manifest entry:
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/get-city-population.sh\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;argsUsage\u0026quot;: \u0026quot;country city\u0026quot; } ... ] } The help message will then look like this:
Usage: cola get-city-population country city [flags] examples #You can add examples to your command\u0026rsquo;s help message. The examples property defines a list of examples for your command. Each example contains two fields: scenario and command:
scenario, describes the use case. cmd, demonstrates the command to apply for the particular use case. For example:
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/get-city-population.sh\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;argsUsage\u0026quot;: \u0026quot;country city\u0026quot; \u0026quot;examples\u0026quot;: [ { \u0026quot;scenario\u0026quot;: \u0026quot;get the city population of Paris, France\u0026quot;, \u0026quot;cmd\u0026quot;: \u0026quot;get-city-population France Paris\u0026quot; } ] } ... ] } The help message looks like:
... Usage: cola get-city-population country city [flags] Example: # get the city population of Paris, France get-city-population France Paris ... executable #The executable to call when your command is triggered from Command Launcher.
You can inject predefined variables in the executable location string. For details about those variables see Manifest Variables
Example:
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/my-binary{{.Extension}}\u0026quot; } ] } args #The arguments that are to be appended to the executable when the command is triggered. The other arguments passed from Command Launcher will be appended after these arguments that are defined in the args field.
Example:
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;crawler\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;java\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-jar\u0026quot;, \u0026quot;{{.PackageDir}}/bin/crawler.jar\u0026quot;] } ] } When we call this command from Command Launcher:
cola crawler --url https://example.com It executes following command:
java -jar {{package path}}/bin/crawler.jar --url https://example.com Note: you can use variables in args fields as well. See Variables
validArgs #A static list of the arguments to offer when auto-completing the command.
Example:
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;validArgs\u0026quot;: [ \u0026quot;paris\u0026quot;, \u0026quot;rome\u0026quot;, \u0026quot;london\u0026quot; ] } ] } Once you have configured auto-complete for Command Launcher, the command described above will have auto-completion for its arguments.
When you type: [cola] city population [TAB], your shell will prompt options: paris, rome, and london.
validArgsCmd #A command to execute to get the dynamic list of valid arguments for auto-completion.
This command can take its own arguments and must be specified as an array of strings.
Example:
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;validArgsCmd\u0026quot;: [ \u0026quot;{{.PackageDir}}/bin/population-cities.sh\u0026quot;, \u0026quot;-H\u0026quot;, ] } ] } When you type [cola] city poplution [TAB], command launcher will run the command specified in this field, and append all existing flags/arguments to the validArgsCmd.
More details see: Auto-Complete
flags #Available in 1.9+
Define flags (options) of the command. Each flag could have the following properties
Property Required Description name yes flag name short no flag short name, usually one letter desc no flag description type no flag type, default \u0026ldquo;string\u0026rdquo;, currently supporting \u0026ldquo;string\u0026rdquo; and bool\u0026quot; default no flag default value, only available for string type, bool flag\u0026rsquo;s default is always false required no boolean, is the flag required, default false values no list of values for the flag for Auto-Complete. Available in 1.10.0+ valuesCmd no list of strings. The command to call to get available values for auto-complete. Available in 1.10.0+ Example:
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;validArgs\u0026quot;: [ \u0026quot;paris\u0026quot;, \u0026quot;rome\u0026quot;, \u0026quot;london\u0026quot; ], \u0026quot;flags\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;human\u0026quot;, \u0026quot;short\u0026quot;: \u0026quot;H\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;return the human readable format\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot; } ] } ] } exclusiveFlags #Available in 1.9+
Declare two or more flags are mutually exclusive. For example, a flag json that outputs in JSON format will be exclusive to the flag text, which outputs in plain text format.
Example:
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;validArgs\u0026quot;: [ \u0026quot;paris\u0026quot;, \u0026quot;rome\u0026quot;, \u0026quot;london\u0026quot; ], \u0026quot;flags\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;human\u0026quot;, \u0026quot;short\u0026quot;: \u0026quot;H\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;return the human readable format\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;json\u0026quot;, \u0026quot;short\u0026quot;: \u0026quot;j\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;return the JSON format\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;bool\u0026quot; } ], \u0026quot;exclusiveFlags\u0026quot;: [ [ \u0026quot;human\u0026quot;, \u0026quot;json\u0026quot; ] ] } ] } groupFlags #Available in 1.9+
Ensure that two or more flags are presented at the same time.
Example:
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;flags\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;country\u0026quot;, \u0026quot;short\u0026quot;: \u0026quot;c\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;country name\u0026quot;, \u0026quot;required\u0026quot;: true }, { \u0026quot;name\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;short\u0026quot;: \u0026quot;t\u0026quot;, \u0026quot;desc\u0026quot;: \u0026quot;city name\u0026quot; } ], \u0026quot;groupFlags\u0026quot;: [ [ \u0026quot;country\u0026quot;, \u0026quot;city\u0026quot; ] ] } ] } requiredFlags #Deprecated in 1.9, see flags property
The static list of flags for your command.
Example:
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;validArgs\u0026quot;: [ \u0026quot;paris\u0026quot;, \u0026quot;rome\u0026quot;, \u0026quot;london\u0026quot; ], \u0026quot;requiredFlags\u0026quot;: [ \u0026quot;human\\t H\\t return the human readable format\u0026quot;, ] } ] } It declares a --human flags with a short form: -H
The flag definition string uses \\t to separate different fields. A complete fields can be found in the following table
field position field name field description 1 flag full name the full name of the flags, usually in format of x-y-z, note: no need to include -- in the name 2 flag short name optional, the short name (one letter) for the flag 3 flag description optional, the description of the flag name 4 flag type optional, the flag type, one of string and bool. Default: string 5 flag default value optional, the default value if not specified Besides the complete form, it is also possible to have a short form:
only the full name: ex. \u0026ldquo;user-name\u0026rdquo; full name + description: ex. \u0026ldquo;user-name\\t the user name\u0026rdquo; full name + short name + description: ex. \u0026ldquo;user-name\\t u\\t the user name\u0026rdquo; checkFlags #Whether to parse and check flags before execute the command. Default: false.
The requiredFlags (deprecated in 1.9), flags, validArgs and validArgsCmd are mainly used for auto-completion. Command Launcher will not parse the flag and arguments by default, it will simply pass through them to the callee command. In other words, in this case, it is the callee command\u0026rsquo;s responsibility to parse the flags and arguments. This works fine when the command is implemented with languages that have advanced command line support, like golang.
In other cases, argument parsing is difficult or has less support, for example, implementing the command in shell script. Enabling checkFlags will allow Command Launcher to parse the arguments and catch errors. Furthermore, Command Launcher will pass the parsed flags and arguments to the callee command through environment variables:
For flags: COLA_FLAG_[FLAG_NAME] (\u0026rsquo;-\u0026rsquo; is replaced with \u0026lsquo;_\u0026rsquo;). Example: flag --user-name is passed through environment variable COLA_FLAG_USER_NAME
For arguments: COLA_ARG_[INDEX] where the index starts from 1. Example: command cola get-city-population France Paris will get environment variable COLA_ARG_1=France and COLA_ARG_2=Paris. An additional environment variable COLA_NARGS (available in 1.9+) is available as well to get the number of parsed arguments.
Even checkFlags is set to true, command launcher will still pass through the original arguments to the callee command as well; in addition to the original arguments, parsed flags and arguments are passed to the callee as environment variables.
Another behavior change is that once checkFlags is enabled, the -h and --help flags are handled by Command Launcher. The original behavior is for these to be managed by the callee command itself.
requestedResources #Under the user consent, Command Launcher can pass several resources to the callee command, for example, the user credentials collected and stored securely by the built-in login command. The requestedResources property is used to request such resources. Command Launcher will prompt user consent for the first time, and pass requested resources value to the callee command through environment variables. More detail see: Manage resources
The following snippet requests access the USERNAME and PASSWORD resources.
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;requestedResources\u0026quot;: [ \u0026quot;USERNAME\u0026quot;, \u0026quot;PASSWORD\u0026quot; ] } ] } System commands #Besides the system command defined in a system package. You can define a package-level system command as a lifecycle hook.
__setup__ #When a package is installed, sometimes it requires some setup to make it work properly. For example, a command written in javascript could require a npm install to install all of its dependencies. You can define a system command __setup__ in your package as a normal command, with type system, it will be called when the package is installed. (You can disable this behavior, by turning the configuration enable_package_setup_hook to false). You can also manually trigger it through the built-in command: cola package setup
Make sure the setup hook is idempotent, when a new version is installed the setup hook will be called again.
Example:
pkgName: package-demo version: 1.0.0 cmds: - name: __setup__ type: system executable: \u0026quot;{{.PackageDir}}/hooks/setup-hook\u0026quot; args: [ \u0026quot;predefined-arg1\u0026quot;, \u0026quot;predefined-arg2\u0026quot; ] - name: other-commands type: executable executable: \u0026quot;{{.PackageDir}}/scripts/other-cmd.sh\u0026quot; `}),e.add({id:10,href:"https://criteo.github.io/command-launcher/docs/overview/enterprise/",title:"Enterprise Setup Guide",description:"Setup command launcher for enterprise scenarios",content:`Setup remote configuration #For enterprise use case, it is common to enforce some configurations for all users. For example, the remote registry to synchronise local commands. You can specify a remote configuration file using COLA_REMOTE_CONFIG_URL environment variable for this purpose.
export COLA_REMOTE_CONFIG_URL=https://remote-server/remote-config.json The remote configuration is a JSON file contains the configuration items that you would like to enforce. Command launcher will override the local configuration item when the item is defined in the remote configuration.
For example, you can setup self_update_enabled to true in the remote configuration file. This will ensure that all users get the latest version of command launcher automatically.
Remote configuration synchronise cycle #It is always nice to be able to change the configuration temporarily. Command launcher will check the remote configuration periodically. You can setup this check period from the configuration: remote_config_check_cycle.
For example, the following configuration set up a 24-hour check period.
{ ... \u0026quot;remote_config_check_cycle\u0026quot;: 24, ... } For the configuration items, which are missing from the remote configuration. The local value is always respected.
Command auto-update: setup remote registry #Another common use case for enterprise scenario is to ensure the same set and same version of commands available on a group of users. (For example, all engineers have the same version of build and test command).
You can setup a remote package registry to list the available packages. Command launcher will synchronise with it at the end of each command call and make sure the local copy is synchronised with the remote package registry (always use the latest version available on the remote registry).
Remote repository registry is a json file, which contains all available packages:
The following example demonstrates a registry, which has three packages. Note that the package \u0026ldquo;hotfix\u0026rdquo; has two different versions, and the version 1.0.0-45149 targets to 30% of the user (partition 6, 7, and 8). More details about the partition see Progressive Rollout
[ { \u0026quot;name\u0026quot;: \u0026quot;hotfix\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0-44733\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;5f5f47e4966b984a4c7d33003dd2bbe8fff5d31bf2bee0c6db3add099e4542b3\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://the-url-of-the-env-package/any-name.zip\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 }, { \u0026quot;name\u0026quot;: \u0026quot;hotfix\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0-45149\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;773a919429e50346a7a002eb3ecbf2b48d058bae014df112119a67fc7d9a3598\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://the-url-of-the-env-package/hotfix-1.0.0-45149.zip\u0026quot;, \u0026quot;startPartition\u0026quot;: 6, \u0026quot;endPartition\u0026quot;: 8 }, { \u0026quot;name\u0026quot;: \u0026quot;env\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;c87a417cce3d26777bcc6b8b0dea2ec43a0d78486438b1bf3f3fbd2cafc2c7cc\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://the-url-of-the-env-package/package.zip\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 } ] You can host this index.json file on an http server, for example: https://my-company.com/cola-remote-registry/index.json.
To make command launcher be aware of the remote package registry, setup the configuration:
cola config command_repository_base_url https://my-company.com/cola-remote-registry Use command launcher on CI #Another use case of using command launcher is for Continuous Integration (CI). In this case, we would like to pin the version of command to have a deterministic behavior.
Two configurations will help us achieve it: ci_enabled and package_lock_file.
When enabled, the ci_enabled bool configuration tells command launcher to read a \u0026ldquo;lock\u0026rdquo; file to get the package version instead of using the latest one from remote registry. The lock file is specified in the package_lock_file configuration.
When ci_enabled config set to false. The lock file is ignored by command launcher.
Package lock JSON file #Package lock file pins the package version in command launcher:
{ \u0026quot;hotfix\u0026quot;: \u0026quot;1.2.0\u0026quot;, \u0026quot;infra-ops\u0026quot;: \u0026quot;3.1.2\u0026quot;, ... } The example above demonstrates a lock file, which pins the hotfix package version to 1.2.0, and infra-ops package version to 3.1.2
NOTE: please make sure the version pinned in lock file are available on the remote package registry.
Partition will be ignored when the version is pinned in a lock file.
Self Auto-update #Command launcher looks for a version metadata endpoint to recognize its latest version, and download the binary follows a URL convention.
The latest version endpoint is defined by self_update_latest_version_url configuration. It must return the latest command launcher version in JSON or YAML format:
In JSON
{ \u0026quot;version\u0026quot;: \u0026quot;45861\u0026quot;, \u0026quot;releaseNotes\u0026quot;: \u0026quot;- feature 1\\n-feature 2\\nfeature 3\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 } Or in YAML
version: \u0026quot;45861\u0026quot; releaseNotes: | * feature 1 * feature 2 * feature 3 startPartition: 0 endPartition: 9 The binary download URL must follow the convention:
[SELF_UPDATE_BASE_URL]/{version}/{binaryName}_{OS}_{ARCH}_{version}{extension} The [SELF_UPDATE_BASE_URL] should be defined in self_update_base_url configuration. The latest {version} can be found in the version metadata from self_update_latest_version_url endpoint. {binaryName} is the short name when building command launcher (default cola). Pre-built {OS} and {ARCH} see following table:
OS Architecture Pre-built windows amd64 yes windows arm64 no linux amd64 yes linux arm64 yes darwin amd64 yes darwin arm64 yes Custom command launcher with system package #See System Package
`}),e.add({id:11,href:"https://criteo.github.io/command-launcher/docs/overview/dropin/",title:"Dropin package",description:"The easiest way to integrate your own scripts/tools to command launcher",content:`What is dropin package? and why do I need it? #A dropin package is a package that is only available on the local machine, rather than managed by the remote repository. It allows developers to integrate their own scripts/tools into Command Launcher to benefit from the features provided by the command launcher, such as auto-complete, monitoring, etc.
For example, you probably already have lots of shell scripts to maintain your infrastructure. Writing auto-completion for all these scripts is time consuming and it is difficult to remember which script does what, and what parameters they accept. Writing a manifest.mf file is enough to let Command Launcher manage these scripts for you with auto-complete, secret management, and monitoring.
A dropin package is also a good way for you to develop and test your Command Launcher package, as it follows the same structure as a regular package.
How to create a dropin package? #identify the dropins folder: run the following command:
cola config dropin_folder If the dropin folder returned by the command doesn\u0026rsquo;t exist, create it.
create a package folder in the dropin folder, let\u0026rsquo;s say, a package named my-first-package. You can name it whatever you want.
add a manifest.mf file in the newly created package folder, follow the MANIFEST guide to define your commands in this file. Note: you can copy your scripts in the package folder and use {{.PackageDir}} to reference the package location in your manifest file.
run cola any time to test your command
How to share a dropin package with others? #A dropin package is simply a directory with manifest.mf file in it; the best way to share a dropin package is to push it to a git repository and ask others to clone it in their own dropin folder.
Starting from 1.7.0, you can use the built-in install command to install a dropin package hosted in a git repository or a zip file:
cola package install --git https://github.com/criteo/command-launcher-package-example If you uploaded your package to an HTTP server as a zip file, you can install it with cola install --file
cola package install --file https://github.com/criteo/command-launcher/raw/main/examples/remote-repo/command-launcher-demo-1.0.0.pkg How to update a dropin package? #Command Launcher does not currently update the dropin folder automatically, it is up to developers themselves to keep these dropin packages up-to-date.
`}),e.add({id:12,href:"https://criteo.github.io/command-launcher/docs/overview/resources/",title:"Manage resources",description:"Access informations that collected from command launcher",content:`What are Resources #Resources are the information collected by Command Launcher. One good example is the username and password from the built-in login command.
Some of these pieces of information require user consent to access them, a command needs to explicitly request the access to these resources through the requestedResources property in the manifest.
Others are automatically passed to the command.
Command Launcher passes resources to managed commands through environment variables. The naming convention is: COLA_[RESOURCE_NAME]. If you compiled command launcher to a different name, command launcher will pass an additional environment variable [APP_NAME]_[RESOURCE_NAME] to the managed command as well.
For example, the following snippet of manifest requests the resource USERNAME and AUTH_TOKEN.
pkgName: infra-management version: 1.0.0 cmds: - name: create-pod ... requestedResources: [ \u0026quot;USERNAME\u0026quot;, \u0026quot;AUTH_TOKEN\u0026quot; ] User consent #Command launcher will pass the resources to the command on runtime through environment variables: COLA_[RESOURCE_NAME], ONLY IF user has agreed to do so. This is done through a user consent process, with a prompt message for the first-time run of the command:
Command 'create-pod' requests access to the following resources: - USERNAME - AUTH_TOKEN authorize the access? [yN] The user consent will last for a specific period of time define in the user_consent_life configuration entry.
Access resources in your command #Once the user grants access to the requested resources, Command Launcher will pass the resources to the command at runtime through environment variables with the naming convention: COLA_[RESOURCE_NAME]. Here is an example of a bash script:
#!/bin/bash USERNAME=\${COLA_USERNAME} AUTH_TOKEN=\${COLA_AUTH_TOKEN} Available resources #Resource Name Require User Consent Description USERNAME Yes the username collected from login command PASSWORD Yes the password collected from login command AUTH_TOKEN Yes the authentication token collected from login command LOG_LEVEL No the log level of command launcher DEBUG_FLAGS No the debug flags defined in command launcher\u0026rsquo;s config PACKAGE_DIR No the absolute path to the package directory FULL_COMMAND_NAME No the name of the command executed (includes app and group) `}),e.add({id:13,href:"https://criteo.github.io/command-launcher/docs/tutorial/",title:"Tutorials",description:"",content:""}),e.add({id:14,href:"https://criteo.github.io/command-launcher/docs/overview/system-package/",title:"System package",description:"Extend command launcher's built-in function with system package",content:`What is a System Package #A System Package is like any other Command Launcher package, with one manifest.mf file in it to describe the commands, and containing binaries, scripts, and resources to execute those commands.
The difference is that a System Package contains system commands, and it can only be installed from a central repository (not as a dropin package).
You can customize your Command Launcher by providing a system package. In a system package, you can define system commands as functional hooks to extend Command Launcher\u0026rsquo;s built-in functionalities, for example, login and metrics.
Define system package #To specify which package is the system package, use the configuration system_package.
cola config system_package your-system-package-name An example system package manifest looks like this:
pkgName: system-package-demo version: 1.0.0 cmds: - name: __login__ type: system executable: \u0026quot;{{.PackageDir}}/hooks/login-hook\u0026quot; - name: __metrics__ type: system executable: \u0026quot;{{.PackageDir}}/hooks/metrics-hook\u0026quot; - name: other-commands type: executable executable: \u0026quot;{{.PackageDir}}/scripts/other-cmd.sh\u0026quot; NOTE: The system command will be ignored if the package is not defined as system package.
System commands #To extend Command Launcher built-in functionality, you need to specify some system type commands in a system package. The following table lists available system commands:
system command name description __login__ calling your IAM system to return login_token __metrics__ collect metrics System command __login__ #The built-in login command will trigger the __login__ system command. It takes two arguments:
username password __login__ [username] [password] The __login__ system command outputs the credentials to be stored by command launcher in a JSON format. The credentials could be one or many of following items:
credential name description environment variable username the user name COLA_USERNAME password the password COLA_PASSWORD auth_token the authentication token COLA_AUTH_TOKEN For example: the following output tells command launcher to store the username and the auth_token, but not store the password.
{ \u0026quot;username\u0026quot;: \u0026quot;joe\u0026quot;, \u0026quot;auth_token\u0026quot;: \u0026quot;DZ4OfC4vS38!\u0026quot; } To use these credentials see Manage resources
System command __metrics__ #At the end of each Command Launcher execution, the __metrics__ system hook will be triggered. The following arguments will be passed to the __metrics__ system command in order:
repository/registry name (see remote command) package name command group name, or \u0026ldquo;default\u0026rdquo; if no group command name user partition command exit code command execution duration in nano seconds error message or \u0026ldquo;nil\u0026rdquo; if no error command start timestamp in seconds Here is an example:
__metrics__ default example cola-example hello 2 0 5000000 nil 1668363339 Note: the __metrics__ hook will be called at the end of each Command Launcher call, please make sure it ends fast to reduce the footprint.
`}),e.add({id:15,href:"https://criteo.github.io/command-launcher/docs/overview/variable/",title:"Variables in manifest",description:"Use of variables in the manifest.mf file",content:`The values of certain fields in the manifest file can be set using predefined variables. These variables are replaced with their actual values at runtime.
The two most common use cases of variables in a Command Launcher\u0026rsquo;s manifest.mf file are:
Referencing files that are located in the package directory itself Providing system/architecture-aware commands, for example, .sh script for linux, and .bat script for windows Available Variables #Variable Name Variable Description PackageDir The absolute path of the package Root Same as the \u0026ldquo;PackageDir\u0026rdquo; variable Cache Same as the \u0026ldquo;PackageDir\u0026rdquo; variable Os The OS: \u0026ldquo;windows\u0026rdquo;, \u0026ldquo;linux\u0026rdquo;, or \u0026ldquo;darwin\u0026rdquo; Arch The system architecture: \u0026ldquo;arm64\u0026rdquo;, \u0026ldquo;amd64\u0026rdquo; Binary The binary file name of the Command Launcher Extension The system-aware binary extension, \u0026quot;\u0026quot; for linux, \u0026ldquo;.exe\u0026rdquo; for windows ScriptExtension The system-aware script extension, \u0026ldquo;.sh\u0026rdquo; for linux, \u0026ldquo;.bat\u0026rdquo; for windows Fields that accept variables #Variables can only be used in the command properties: executable, args, and validArgsCmd
How to use these variables #You can reference them in this format: {{.Variable}}. For example:
\u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;variable-demo\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/script{{.ScripteExtension}}\u0026quot;, } ] The executable on Linux will be a script called script.sh located in the bin folder of the package. On windows, the executable will be a script called script.bat.
If Else #One common scenario is to have a different path or file name, depending on what OS Command Launcher is running on. You can use a conditional structure (if-else) in the fields that accept variables. For example:
\u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;variable-demo\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/script{{if eq .Os \\\u0026quot;windows\\\u0026quot;}}.ps1{{else}}.sh{{end}}\u0026quot;, } ] The executable on Linux will be a script called script.sh located in the bin folder of the package. On Windows, the executable will be a script called script.ps1.
Advanced usage of variables #See golang text/template for advanced usage.
`}),e.add({id:16,href:"https://criteo.github.io/command-launcher/docs/",title:"Docs",description:"Command Launcher Docs",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()