var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],field:["title","description","content"],index:["title","description","content"]}});e.add({id:0,href:"https://criteo.github.io/command-launcher/docs/quickstart/",title:"Quickstart",description:"",content:""}),e.add({id:1,href:"https://criteo.github.io/command-launcher/docs/quickstart/binary-install/",title:"Binary install",description:"Install command launcher with pre-built binaries",content:`Download pre-built binaries #Pre-built binaries can be downloaded from the Github release page. Copy the binary into your PATH.
The default pre-built binary is named cola (Command Launcher), if you want to use a different name, you can build your own binaries from source. See build from source.
For example, in each release, we also build a binary named cdt (Criteo Dev Toolkit). If you prefer to download cdt, please replace cola to cdt in the examples from the documents.
Setup auto-completion #Command launcher will automatically handle auto completion for all sub commands. You need to setup it once:
Bash #\$ source \u0026lt;(cola completion bash) # To load completions for each session, execute once: # Linux: \$ cola completion bash \u0026gt; /etc/bash_completion.d/cola # macOS: \$ cola completion bash \u0026gt; \$(brew --prefix)/etc/bash_completion.d/cola Zsh ## If shell completion is not already enabled in your environment, # you will need to enable it. You can execute the following once: \$ echo \u0026quot;autoload -U compinit; compinit\u0026quot; \u0026gt;\u0026gt; ~/.zshrc # To load completions for each session, execute once: \$ cola completion zsh \u0026gt; \u0026quot;\${fpath[1]}/_cola\u0026quot; # You will need to start a new shell for this setup to take effect. Powershell #PS\u0026gt; cola completion powershell | Out-String | Invoke-Expression # To load completions for every new session, run: PS\u0026gt; cola completion powershell \u0026gt; cola.ps1 # and source this file from your PowerShell profile. Fish #\$ cola completion fish | source # To load completions for each session, execute once: \$ cola completion fish \u0026gt; ~/.config/fish/completions/cola.fish Uninstall #Simply delete the binary.
Build from source #Command launcher is easy to build from source, follow the instructions
`}),e.add({id:2,href:"https://criteo.github.io/command-launcher/docs/quickstart/build-from-source/",title:"Build from source",description:"Build command launcher from source",content:`Why does the binary name matter? #Command launcher is designed for both enterprise and individual usage. According to your context, you might want to call it differently. For example, at Criteo, we call it \u0026ldquo;Criteo Dev Toolkit\u0026rdquo;. The binary name is used for several default configurations, for example, command launcher home \$HOME/.[APP_NAME], additional resources environment prefix [APP_NAME]_, etc.
The default pre-built binary is call cola (Command Launcher), which means that the default home folder is \$HOME/.cola and the resources environment variables are all starts with COLA_.
Another pre-built binary is called cdt (Criteo Dev Toolkit), its home folder will be \$HOME/.cdt, and its commands can access the resource environment variables with both prefix COLA_ and CDT_.
For compatibility concern, we highly recommend to reference resources in your command with prefix COLA_
To use a different name, you need to build command launcher from source and pass the desired short and long name to the build scripts.
Build from source #Requirements: golang \u0026gt;= 1.17
You can build the command launcher with your prefered name (in the example: Command Launcher, a.k.a cola).
go build -o cola -ldflags='-X main.version=dev -X main.appName=cola -X \u0026quot;main.appLongName=Command Launcher\u0026quot;' main.go Or simply call the build.sh scripts
./build.sh [version] [app name] [app long name] Run tests #go test -v ./... `}),e.add({id:3,href:"https://criteo.github.io/command-launcher/docs/quickstart/first-command/",title:"Quick Start",description:"Integrate your first command to command launcher",content:`Preparation #If you want to use the default command launcher binary name (cola): install command launcher following the guide Binary install. Or if you prefer a different binary name, build command launcher from source: Build from source
In Criteo, we call it cdt, (Criteo Dev Toolkit)
In this tutorial, we will use the binary name cola.
To check your command launcher installation, run following command:
cola config It should list all your configurations. The important ones for this tutorial is the following:
dropin_folder : [command launcher home]/dropins local_command_repository_dirname : [command launcher home]/current Default command launcher home: MacOS/Users/[user_name]/[.binary_name] Linux/home/[user_name]/[.binary_name] WindowsC:\\Users\\[user_name]\\[.binary_name]
For example, on my Macbook (with user criteo), my command launcher home is /Users/criteo/.cola
Command launcher also provide auto-completion feature to all managed commands, you only need to setup auto-completion once: setup auto-completion
Let\u0026rsquo;s build a command #If you already have a command you can skip this step. Command launcher is technology agnostic to your command. You can build your command in any tech stack that suits your use case. In this tutorial, let\u0026rsquo;s build a simple \u0026ldquo;Hello World\u0026rdquo; command line tool with bash scripts.
In command launcher, commands are packaged into packages. Let\u0026rsquo;s first create a package for our newly created command:
cd \$HOME/.cola/dropins mkdir my-first-package cd my-first-package Create a script file first-command-launcher-cmd.sh, which prints greeting message according to the language
#!/bin/bash LANG=\${LANG:-en} if [ \$LANG == \u0026quot;fr\u0026quot; ]; then echo \u0026quot;Bonjour! \$1\u0026quot; exit 0 else echo \u0026quot;Hello! \$1\u0026quot; exit 0 fi You can run it directly as a normal bash script:
\$ ./first-command-launcher-cmd.sh \u0026quot;command launcher\u0026quot; Hello! command launcher \$ LANG=fr ./first-command-launcher-cmd.sh \u0026quot;command launcher\u0026quot; Bonjour! command launcher Prepare a minimal manifest.mf #Now we have a working command/script. To make command launcher aware of it, we need to create a manifest file (in JSON or YAML format) at the root folder of the package:
manifest.mf
pkgName: my-first-package version: 0.0.1 cmds: - name: greeting type: executable executable: \u0026quot;{{.PackageDir}}/first-command-launcher-cmd.sh\u0026quot; That\u0026rsquo;s it! Your command has been integrated to command launcher with a subcommand named greeting, to test it:
\$ cola greeting \u0026quot;command launcher\u0026quot; Hello! command launcher \$ LANG=fr cola greeting \u0026quot;command launcher\u0026quot; Bonjour! command launcher Command launcher will pass all the environment variables, arguments to itself to your command.
Tell more about your command to command launcher #We can go even further to turn our bash scripts into a native-like program. Let\u0026rsquo;s add extra information in the manifest, and make some improvements of its user interface:
the short and long description some examples use a flag to take language input instead of environment variable LANG pkgName: my-first-package version: 0.0.2 cmds: name: greeting type: executable short: Simple greeting command executable: \u0026quot;{{.PackageDir}}/first-command-launcher-cmd.sh\u0026quot; requiredFlags: - \u0026quot;language\\t greeting language\u0026quot; examples: - scenario: Greeting with default language cmd: greeting [name] - scenario: Specify the greeting language cmd: greeting --language fr [name] checkFlags: true The above manifest tells command launcher that the greeting command requires a flags called language, and let command launcher to check the flags before calling the script
Now when you run the greeting command with -h or --help, you will get a nice help message like a native command:
\$ cola greeting -h Usage: cola greeting [flags] Examples: # Greeting with default language greeting [name] # Specify the greeting language greeting --language fr [name] Flags: -h, --help help for greeting --language string greeting language But how can our script get the language passed from the --language flag? Command launcher passes an environment variable to your script with the name CDT_FLAG_LANGUAGE (More details see checkFlags). You can modify your script to get the language from it like so:
#!/bin/bash LANG=\${COLA_FLAG_LANGUAGE:-en} if [ \$LANG == \u0026quot;fr\u0026quot; ]; then echo \u0026quot;Bonjour! \$1\u0026quot; exit 0 else echo \u0026quot;Hello! \$1\u0026quot; exit 0 fi Now we have turned our bash script into a native-like command.
Auto-completion #Command launcher will automatically enable auto-completion for your command. Subcommand, flags, arguments will will be auto-completed when you type [TAB][TAB], for example:
\$ cola g[TAB][TAB] greeting - Simple greeting command grepx - Enhanced grep command \$ cola greeting --[TAB][TAB] \$ cola greeting --language `}),e.add({id:4,href:"https://criteo.github.io/command-launcher/docs/overview/",title:"Overview",description:"Command Launcher Overview",content:""}),e.add({id:5,href:"https://criteo.github.io/command-launcher/docs/overview/introduction/",title:"Introduction",description:"Overall introduction of command launcher",content:`What is command launcher? #Command launcher is a small footprint, rich feature CLI management tool for both enterprise and individual CLI developers. It eases the command line tool development by providing built-in common functionalities like: monitoring, progressive rollout, auto-completion, credential management, and more to your commands.
Why a command launcher? #At Criteo, we have many teams who provides command line applications for developers. These CLI providers repeatly handle the same features and functionalities for their CLI apps, such as auto-completion, credential management, release, delivery, monitoring, etc.
On developer side, they have to manually download these tools to keep them up-to-date, it is difficult for them to discover available new tools. On the other hand, different developers have developed lots of similar handy scripts/tools by themselves without an easy way to share with others to avoid \u0026ldquo;re-inventing\u0026rdquo; the wheel.
To improve both developer and CLI provider\u0026rsquo;s experience, we developed a command launcher to solve the above issues. It has built-in features like auto-completion, credential management, progressive roll-out, and monitoring, so that the CLI app provider can focus on the functionality of their CLI app. Developers only need to download the command launcher to access all these CLI apps. The command launcher will keep their CLI application up-to-date. The dropin feature allows developers to integrate their own scripts/tools into command launcher and share with others. These scripts and tools can also benefits from built-in features like auto-completion, and monitoring.
How it works? #Command launcher is a small binary downloaded by developer in their development environment. CLI provider packages new commands or new version of command into a package, upload it to a remote repository, and update the package index of the repository. This process can be automated. More details about the remote repository, see CLI Provider Guide
Developers can integrate their own commands into command launcher as a \u0026ldquo;dropin\u0026rdquo; package. These dropin package will be only accessible from the developers themselves. To share such commands see Dropin Package
Developers run command launcher to access these commands, for example, you have a command called toto, instead of run it directly from command line, you use cl toto, where cl is the binary name of the command launcher, you can name it anything suits you. Every time you execute command launcher, it will synchronize with the remote command, and propose available updates if exists.
┌──────────────────┐ Synch ┌───────────────────────────┐ ┌──────────────│ command launcher │◄────────────│ Remote Command Repository │ │ └──────────────────┘ └───────────────────────────┘ │ │ │ │ ┌──────────┼──────────┐ ┌────────────┼────────────┐ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ┌─────────┐ ┌───────┐ ┌───────┐ ┌───────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ dropins │ │ cmd A │ │ cmd B │ │ cmd C │ │ cmd A │ │ cmd B │ │ cmd C │ └────┬────┘ └───────┘ └───────┘ └───────┘ └─────────┘ └─────────┘ └─────────┘ ┌──────┴──────┐ ▼ ▼ ┌────────┐ ┌────────┐ │ cmd D │ │ cmd E │ └────────┘ └────────┘ Features #Small footprint. Command launcher is around 10M, with no dependency to your OS. Technology agnostic. It can launch commands implemented in any technology, and integrate to it with a simple manifest file. Auto-completion. It supports auto-completion for all your commands installed by it. Auto-update. Not only keeps itself but all its commands up-to-date. Credential management. With the built-in login command, it securely passes user credential to your command. Progressive rollout. Target a new version of command to a group of beta test users, and rollout progressively to all your users. Monitoring. Built-in monitoring feature to monitor the usage your commands. Dropins. Easy to intergrate your own command line scripts/tools by dropping your manifest in the \u0026ldquo;dropins\u0026rdquo; folder. Installation #Pre-built binary can be downloaded from the release page. Unzip it, copy the binary into your PATH.
The two pre-built binaries are named cola (Command Launcher) and cdt (Criteo Dev Toolkit), if you want to use a different name, you can pass your prefered name in the build. See build section below.
Build #Requirements: golang \u0026gt;= 1.17
You can build the command launcher with your prefered name (in the example: Criteo Developer Toolkit, a.k.a cdt).
go build -o cdt -ldflags='-X main.version=dev -X main.appName=cdt -X \u0026quot;main.appLongName=Criteo Dev Toolkit\u0026quot;' main.go Or simply call the build.sh scripts
./build.sh [version] [app name] [app long name] Run tests #go test -v ./... Release #Simply tag a commit with format \u0026lsquo;x.y.z\u0026rsquo;, and push it.
git tag x.y.z git push origin x.y.z The supported release tag format:
*.*.* *.*.*-* Example: 1.0.0, 1.0.1-preview
`}),e.add({id:6,href:"https://criteo.github.io/command-launcher/docs/overview/built-in-commands/",title:"Built-in commands",description:"Command launcher built-in commands",content:`config #Get or set command launcher configuration.
Use cola config to list all configurations.
Use cola config [key] to get one configuration.
Use cola config [key] [value] to set one configuration.
completion #Setup auto completion. See help to get instructions:
cola completion --help login #Store your credentials securely and pass them to managed commands when requested and under your agreements. More details see: Managed resources
update #Check updates for command launcher and managed commands.
version #Return command launcher version information.
`}),e.add({id:7,href:"https://criteo.github.io/command-launcher/docs/overview/provider-guide/",title:"CLI provider guide",description:"Complete guide to integrate your CLI to command launcher",content:` NOTE: in this page, we use cola as the command launcher\u0026rsquo;s binary name, you can build your own command launcher with a different name. See: build from source
Command launcher synchronizes commands from the remote command repository. Commands are packaged into a package, then uploaded to remote command repository. The following diagram shows this architecture.
┌─────────────────────────────┐ │ Remote Command Repository │ └──────────────┬──────────────┘ ┌───────────┴────────────┐ ▼ ▼ ┌────────────┐ ┌───────────┐ │ pacakge 1 │ │ pakcage 2 │ └────────────┘ └───────────┘ │ │ ┌───────┤─────────┐ ┌───┴────┐ ▼ ▼ ▼ ▼ ▼ ┌───────┐┌───────┐┌───────┐ ┌───────┐┌───────┐ │ cmd A ││ cmd B ││ cmd C │ │ cmd D ││ cmd E │ └───────┘└───────┘└───────┘ └───────┘└───────┘ Remote command repository #A remote command repository is a simple http server with following endpoints:
/index.json, which returns the list of packages available. It is up-to-you to implement such an http server. You can configure command launcher to point to your remote repository with following command:
cola config command_repository_base_url https://my-remote-repository/root/url NOTE: the command launcher will search for [command_repository_base_url]/index.json for the remote registry. You can also use a local folder as the \u0026ldquo;base url\u0026rdquo;, for example, /tmp/cola-remote-repository/. In this case, you need to create the index.json registry file in the folder. This is useful for test purpose.
You need to config an endpoint to auto update command launcher itself as well:
cola config self_update_latest_version_url https://my-remote-repository/cola/root/url/version cola config self_update_base_url https://my-remote-repository/cola/root/url The self_update_latest_version_url configuration defines the url to download the metadata of command launchers\u0026rsquo;s latest version in YAML or JSON format, see: Command Launcher version metadata
The self_update_base_url configuratin defines the base url to download command launcher binary. It follows the following pattern: [SELF_UPDATE_BASE_URL]/{version}/{binaryName}_{OS}_{ARCH}_{version}{extension}. If you build your own binary, you should make it available following the same convention.
Remote repository registry /index.json #Remote repository registry is a json file, which contains all available packages:
The following example demonstrates a registry, which has three packages. Note that the package \u0026ldquo;hotfix\u0026rdquo; has two different versions, and the version 1.0.0-45149 targets to 30% of the user (partition 6, 7, and 8). More details about the partition see Progressive Rollout
[ { \u0026quot;name\u0026quot;: \u0026quot;hotfix\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0-44733\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;5f5f47e4966b984a4c7d33003dd2bbe8fff5d31bf2bee0c6db3add099e4542b3\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://the-url-of-the-env-package/any-name.zip\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 }, { \u0026quot;name\u0026quot;: \u0026quot;hotfix\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0-45149\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;773a919429e50346a7a002eb3ecbf2b48d058bae014df112119a67fc7d9a3598\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://the-url-of-the-env-package/hotfix-1.0.0-45149.zip\u0026quot;, \u0026quot;startPartition\u0026quot;: 6, \u0026quot;endPartition\u0026quot;: 8 }, { \u0026quot;name\u0026quot;: \u0026quot;env\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;checksum\u0026quot;: \u0026quot;c87a417cce3d26777bcc6b8b0dea2ec43a0d78486438b1bf3f3fbd2cafc2c7cc\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://the-url-of-the-env-package/package.zip\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 } ] Command launcher version metadata #Command launcher update itself by checking an endpoint defined in config self_update_latest_version_url. This endpoint returns the command version metadata:
In JSON
{ \u0026quot;version\u0026quot;: \u0026quot;45861\u0026quot;, \u0026quot;releaseNotes\u0026quot;: \u0026quot;- feature 1\\n-feature 2\\nfeature 3\u0026quot;, \u0026quot;startPartition\u0026quot;: 0, \u0026quot;endPartition\u0026quot;: 9 } Or in YAML
version: \u0026quot;45861\u0026quot; releaseNotes: | * feature 1 * feature 2 * feature 3 startPartition: 0 endPartition: 9 The version metadata endpoint supports both YAML and JSON format. It is recommandded to use YAML for this endpoint because of the multiple line string support in YAML
You can also target a small portion of your command user by specifying the partition. More details see: Progressive Rollout
Integrate your command into command launcher #Package your command into a command package #A command package = zip(your commands, manifest file)
A command package is simply a zip of your command and a manifest file that tell command launcher how to run your command. It is up-to-you to organize the structure of the package, the only requirement here is to keep the manifest.mf file in the root of the package.
For example, the following structure keeps the binary in different folder according to the os.
my-package.pkg ├─linux/ ├─windows/ ├─macosx/ └─manifest.mf Package manifest file, manifest.mf #See manifest.mf specification
Upload your package, and update package registry #Once you have your command package ready, you can upload it to a remote server that command launcher have access. Depends on how you implement the http server of your remote command repository, the upload process could be different, The only requirement here is to ensure your package is accessible from command launcher.
You also need to update the index.json endpoint to include your package in it and specify the package url in the url property.
Progressive Rollout #Command launcher will assign each machine a unique partition ID from 0 to 9. When you roll out your package, you can specify the partition that you want to target to. For example, you just developed a new version, packaged into package my-pkg 1.1.0, uploaded it to remote repository. You can edit the /index.json registry, add following entry to target 40% of your audience (partition 4, 5, 6, and 7):
{ \u0026quot;name\u0026quot;: \u0026quot;my-pkg\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.1.0\u0026quot; \u0026quot;checksum\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;startPartition\u0026quot;: 4, \u0026quot;endPartition\u0026quot;: 7 } You will have different monitoring vectors for each partition, which will help you making A/B tests.
Monitoring #Credential Management #`}),e.add({id:8,href:"https://criteo.github.io/command-launcher/docs/overview/config/",title:"Configuration",description:"List of command launcher configurations",content:`List of configurations #Config Name Type Description ci_enabled bool whether the CI mode is enabled or not command_repository_base_url string the base url of the remote repository, it must contain a /index.json endpoint to list the available pacakges command_update_enabled bool whether auto update managed commands or not dropin_folder string the absolute path of the dropin folder enabled_user_consent bool whether enable the user consent. Be caution, when set to false, all resources are allowed to pass to the managed commands. experimental_command_enabled bool whether enable experimental command or not internal_command_enabled bool whether enable internal command or not local_command_repository_dirname bool the absolute path of the local repository folder. log_enabled bool whether log is enabled or not log_level string the log level of command launcher. Note, the managed command could also request access to this config metric_graphite_host string graphite url for metrics package_lock_file string only available for CI mode (ci_enabled = true). Lock the package version for CI purpose remote_config_check_cycle int interval in hours to check the remote config remote_config_check_time time next remote config check time. This configuration is set automatically by command launcher, you shouldn\u0026rsquo;t change it manually. self_update_base_url string base url to get command launcher binaries self_update_enabled bool whether auto update command launcher itself self_update_latest_version_url string url to get the latest command launcher version information self_update_timeout duration timeout duration for self update usage_metrics_enabled bool whether enable metrics user_consent_life duration the life of user consent Change configuration #It is recommended to use the built-in config command to change the configurations. For duration type configurations, you can use h, m, and s to present hour, minute, and seconds. For example:
cola config user_consent_life 24h sets the user consent life to 24 hours.
`}),e.add({id:9,href:"https://criteo.github.io/command-launcher/docs/overview/manifest/",title:"Manifest.mf",description:"Specification of manifest.mf file",content:`What is a manifest.mf file? #A manifest.mf file is a file located at the root of your command launcher package. It describes the commands packaged in the zip file. When cola installs a package, it reads the manifest file and registers the commands in the manifest file.
Format of manifest.mf #manifest.mf is in JSON or YAML format. It contains 3 fields:
pkgName: a unique name of your package version: the version of your package cmds: a list of command definition, see command definition section Here is an example
{ \u0026quot;pkgName\u0026quot;: \u0026quot;hotfix\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0-44231\u0026quot;, \u0026quot;cmds\u0026quot;: [ ... ] } Command Definition #Command launcher is implemented with cobra. It follows the same command concepts:
Commands represent actions, Args are things and Flags are modifiers for those actions.
The best applications read like sentences when used, and as a result, users intuitively know how to interact with them.
The pattern to follow is APPNAME VERB NOUN \u0026ndash;ADJECTIVE or APPNAME COMMAND ARG \u0026ndash;FLAG.
Each package contains multiple command definitions. You can specify following definition for your command:
Command properties list #Property Required Description name yes the name of your command type yes the type of the command, group or executable group no the group of your command belongs to, default, command launcher root short yes a short description of your command, it will be display in auto-complete options long no a long description of your command argsUsage no custom the one line usage in help examples no a list of example entries executable yes for executable the executable to call when executing your command args no the argument list to pass to the executable, command launcher arguments will be appended to the list validArgs no the static list of options for auto-complete the arguments validArgsCmd no array of string, command to run to get the dynamic auto-complete options for arguments requiredFlags no the static list of options for the command flags checkFlags no whether check the flags defined in manifest before calling the command, default false requestedResources no the resources that the command requested, ex, USERNAME, PASSWORD Command properties #name #The name of the command. A user uses the group and the name of the command to run it:
cola {group} {name} You must make sure your command\u0026rsquo;s group and name combination is unique
type #There are two types of commands: group or executable
An executable type of command is meant to be executed. You must fill the executable and args fields of an executable command.
A group type of command is used to group executable commands.
group #The group of your command. A user uses the group and the name of your command to run it:
cola {group} {name} You must make sure your command\u0026rsquo;s group and name combination is unique
To registry a command at the root level of command launcher, set group to empty string.
Note: command launcher only supports one level of group, the \u0026ldquo;group\u0026rdquo; field of a \u0026ldquo;group\u0026rdquo; type command is ignored.
Example
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;infra\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;group\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;reintall\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;infra\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/reinstall\u0026quot;, \u0026quot;args\u0026quot;: [] } ... ] } The above manifest snippet registered a command: cola infra reinstall, when triggered, it will execute the reinstall binary located in the package\u0026rsquo;s bin folder
short #The short description of the command. It is mostly used as the description in auto-complete options and the list of command in help output. Please keep it in a single line.
long #The long description of the command. In case your command doesn\u0026rsquo;t support \u0026ldquo;-h\u0026rdquo; or \u0026ldquo;\u0026ndash;help\u0026rdquo; flags, command launcher will generate one help command for you, and render your long description in the output.
argsUsage #Custom the one-line usage message. By default, command launcher will generate a one-line usage in the format of:
Usage: APP_NAME group command_name [flags] For some commands that accept multiple types of arguments, it would be nice to have a usage that show the different argument names and their orders. For example, for a command that accepts the 1st argument as country, and 2nd argument as city name, we can custom the usage message with following manifest:
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/get-city-population.sh\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;argsUsage\u0026quot;: \u0026quot;country city\u0026quot; } ... ] } The help message looks like:
Usage: cola get-city-population country city [flags] examples #You can add examples to your command\u0026rsquo;s help message. The examples property defines a list of examples for your command. Each example contains two fields: scenario and command:
scenario, describes the use case. cmd, demonstrates the command to apply for the particular use case. For example:
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/get-city-population.sh\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;argsUsage\u0026quot;: \u0026quot;country city\u0026quot; \u0026quot;examples\u0026quot;: [ { \u0026quot;scenario\u0026quot;: \u0026quot;get the city population of Paris, France\u0026quot;, \u0026quot;cmd\u0026quot;: \u0026quot;get-city-population France Paris\u0026quot; } ] } ... ] } The help message looks like:
... Usage: cola get-city-population country city [flags] Example: # get the city population of Paris, France get-city-population France Paris ... executable #The executable to call when your command is trigger from command launcher. You can inject predefined variables in the executable location string. More detail about the variables see Manifest Variables
Example
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/my-binary{{.Extension}}\u0026quot; } ] } args #The arguments that to be appended to the executable when the command is triggered. The other arguments passed from command launcher will be appeneded after these arguments that are defined in args field.
Example
{ ... \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;crawler\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;java\u0026quot;, \u0026quot;args\u0026quot;: [ \u0026quot;-jar\u0026quot;, \u0026quot;{{.PackageDir}}/bin/crawler.jar\u0026quot;] } ] } When we call this command from command launcher:
cola crawler --url https://example.com It executes following command:
java -jar {{package path}}/bin/crawler.jar --url https://example.com Note: you can use variables in args fields as well. See Variables
validArgs #A static list of the arguments for auto-complete.
Example
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;validArgs\u0026quot;: [ \u0026quot;paris\u0026quot;, \u0026quot;rome\u0026quot;, \u0026quot;london\u0026quot; ] } ] } Once you have configured auto-complete for command launcher, the command described above will have auto-complete for its arguments.
When you type: [cola] city population [TAB], your shell will prompt options: paris, rome, and london
validArgsCmd #A command to execute to get the dynamic list of arguments.
Example
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;validArgsCmd\u0026quot;: [ \u0026quot;{{.PackageDir}}/bin/population-cities.sh\u0026quot;, \u0026quot;-H\u0026quot;, ] } ] } When you type [cola] city poplution [TAB], command launcher will run the command specified in this field, and append all existing flags/arguments to the validArgsCmd.
More details see: Auto-Complete
requiredFlags #The static list of flags for your command
Example
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;validArgs\u0026quot;: [ \u0026quot;paris\u0026quot;, \u0026quot;rome\u0026quot;, \u0026quot;london\u0026quot; ], \u0026quot;requiredFlags\u0026quot;: [ \u0026quot;human\\t H\\t return the human readable format\u0026quot;, ] } ] } It declares a --human flags with a short form: -H
checkFlags #Whether parse and check flags before execute the command. Default: false.
The requiredFlags, validArgs and validArgsCmd are mainly used for auto completion. Command launcher will not parse the arguments by default, it will simply pass the arguments to the callee command. In other words, in this case, it is the callee command\u0026rsquo;s responsibility to parse the flags and arguments. This works fine when the command is implemented with languages that has advanced command line supports, like golang.
For some cases, arguments parsing is difficult or has less support, for example, implementing the command in shell script. Enable checkFlags will allow command launcher to parse the arguments and catch errors. Further more, command launcher will pass the parsed flags and arguments to the callee command through environment variables:
For flags: COLA_FLAG_[FLAG_NAME] (\u0026rsquo;-\u0026rsquo; is replaced with \u0026lsquo;_\u0026rsquo;). Example: flag --user-name is passed through environment variable COLA_FLAG_USER_NAME
For arguments: COLA_ARG_[INDEX] where the index starts from 1. Example: command cola get-city-population France Paris will get environment variable COLA_ARG_1=France and COLA_ARG_2=Paris
Another behavior change is that once checkFlags is enabled, the -h and --help flags are handled by command launcher. The original behavior is managed by the callee command itself.
requestedResources #Under the user consent, command launcher can pass several resources to the callee command, for example, the user credential collected and stored securely by the built-in login command. The requestedResources is used to request such resources. Command launcher will prompt user consent for the first time, and pass requested resources value to the callee command through environment variable. More detail see: Manage resources
The following snippet requests to access the user name and password resources.
{ \u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;population\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;group\u0026quot;: \u0026quot;city\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;get-city-population\u0026quot;, \u0026quot;args\u0026quot;: [], \u0026quot;requestedResources\u0026quot;: [ \u0026quot;USERNAME\u0026quot;, \u0026quot;PASSWORD\u0026quot; ] } ] } `}),e.add({id:10,href:"https://criteo.github.io/command-launcher/docs/overview/dropin/",title:"Dropin package",description:"The easiest way to integrate your own scripts/tools to command launcher",content:`What is dropin package? and why do I need it? #A dropin package is a package that are not managed by the remote repository. It is only available on the developer\u0026rsquo;s machine. It allows developers to integrate their own scripts/tools into command launcher to benefit the feature provided by the command launcher, for example, auto-complete, monitoring etc.
For example, you probably already has lots of shell scripts to maintain your infrastructure. Writing auto-completion for all these scripts is time consuming and it is difficult to remember which script doing what, and what parameters they accept. By writing a simple manifest.mf file, you can let command launcher to manage these scripts for you with auto-complete, secret management, and monitoring.
Dropin package is also a good way for you to develop and test your command launcher package, as it follows the same structure as a regular command launcher package.
How to create a dropin package? #identify the dropins folder: run the following command:
cola config dropin_folder If the dropin folder returned by the command doesn\u0026rsquo;t exist, create it.
create a package folder in the dropin folder, let\u0026rsquo;s say, a package named my-first-package. You can named it whatever you want.
add a manifest.mf in the newly created package folder, follow MANIFEST.md guide to define your command in the manifest file. Note: you can copy your scripts in the package folder and use {{.PackageDir}} to reference the package location in your manifest file.
run cola any time to test your command
How to share a dropin package with others? #A dropin package is simply a directory with manifest.mf in it, the best way to share a dropin package is to push it to a git repository and ask for others to clone it in their own dropin folder
How to update dropin package? #For now, the command launcher does not update the dropin folder automatically, it is up to developers themselve to keep these dropin package up-to-date.
`}),e.add({id:11,href:"https://criteo.github.io/command-launcher/docs/overview/resources/",title:"Manage resources",description:"Access informations that collected from command launcher",content:`What is resources #Resources are the information collected by command launcher. One good example is the user name and password from the built-in login command.
Some of these information require user consent to access them, a command needs to explicitly request the access to these resources through the requestedResources property in the manifest.
Others are automatically passed to the command.
Command Launcher passes resources to managed command through environment variables. The naming convention is: COLA_[RESOURCE_NAME]. If you compiled command launcher to a different name, command launcher will pass an additional environment variable [APP_NAME]_[RESOURCE_NAME] to the managed command as well.
For example, the following snippet of manifest requests the resource USERNAME and LOGIN_TOKEN.
pkgName: infra-management version: 1.0.0 cmds: - name: create-pod ... requestedResources: [ \u0026quot;USERNAME\u0026quot;, \u0026quot;LOGIN_TOKEN\u0026quot; ] User consent #Command launcher will pass the resources to the command on runtime through environment variables: COLA_[RESOURCE_NAME], ONLY IF user has agreed to do so. This is done through a user consent process, with a prompt message for the first-time run of the command:
Command 'create-pod' requests access to the following resources: - USERNAME - LOGIN_TOKEN authorize the access? [yN] The user consent will last for a specific period of time define in user_consent_life configuration.
Access resources in your command #Once user grant the access to the requested resources, command launcher will pass the resources to the command in runtime through environment variable with naming convention: COLA_[RESOURCE_NAME]. Here is an example of bash script:
#!/bin/bash USERNAME=\${COLA_USERNAME} LOGIN_TOKEN=\${COLA_LOGIN_TOKEN} Available resources #Resource Name Require User Consent Description USERNAME Yes the username collected from login command PASSWORD Yes the password collected from login command LOG_LEVEL Yes the log level of command launcher DEBUG_FLAGS Yes the debug flags defined in command launcher\u0026rsquo;s config PACKAGE_DIR No the absolute path to the package directory `}),e.add({id:12,href:"https://criteo.github.io/command-launcher/docs/tutorial/",title:"Tutorials",description:"",content:""}),e.add({id:13,href:"https://criteo.github.io/command-launcher/docs/overview/variable/",title:"Variable",description:"Use variables in manifest.mf file",content:`The two common use cases of integrating commands in command launcher are:
Reference files that are located in the package itself Provide system/architecture-aware commands, for example, .sh script for linux, and .bat script for windows To cover these use cases, in certain fields of the manifest file, predefined variables can used in the field values.
Available Variables #Variable Name Variable Description PackageDir The absolute path of the package Root Same as \u0026ldquo;PackageDir\u0026rdquo; variable Cache Same as \u0026ldquo;PackageDir\u0026rdquo; variable Os The OS, \u0026ldquo;windows\u0026rdquo;, \u0026ldquo;linux\u0026rdquo;, and \u0026ldquo;darwin\u0026rdquo; Arch The system architecture: \u0026ldquo;arm64\u0026rdquo;, \u0026ldquo;amd64\u0026rdquo; Binary The binary file name of the command launcher Extension The system-aware binary extension, \u0026quot;\u0026quot; for linux, \u0026ldquo;.exe\u0026rdquo; for windows ScriptExtension The system-aware scritp extension, \u0026ldquo;.sh\u0026rdquo; for linux, \u0026ldquo;.bat\u0026rdquo; for windows Fields that accepts variables #The command fields: executable, args, and validArgsCmd
How to use these variables #You can reference them in form of {{.Variable}}. For example:
\u0026quot;cmds\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;variable-demo\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;executable\u0026quot;, \u0026quot;executable\u0026quot;: \u0026quot;{{.PackageDir}}/bin/script{{.ScripteExtension}}\u0026quot;, } ] The executable on linux will be a script called script.sh located in the bin folder of the package. On windows, the executable will be a script called script.bat.
Advanced usage of variables #See golang text/template for advanced usage (ex, if else)
`}),e.add({id:14,href:"https://criteo.github.io/command-launcher/docs/",title:"Docs",description:"Command Launcher Docs",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()